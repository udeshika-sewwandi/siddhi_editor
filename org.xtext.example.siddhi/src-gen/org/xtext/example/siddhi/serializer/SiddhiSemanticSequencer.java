/*
 * generated by Xtext 2.11.0
 */
package org.xtext.example.siddhi.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.siddhi.services.SiddhiGrammarAccess;
import org.xtext.example.siddhi.siddhi.AND;
import org.xtext.example.siddhi.siddhi.APP;
import org.xtext.example.siddhi.siddhi.AS;
import org.xtext.example.siddhi.siddhi.AbsentPatternSourceChain;
import org.xtext.example.siddhi.siddhi.AbsentSequenceSourceChain;
import org.xtext.example.siddhi.siddhi.AggregationTimeDuration;
import org.xtext.example.siddhi.siddhi.AggregationTimeRange;
import org.xtext.example.siddhi.siddhi.Annotation;
import org.xtext.example.siddhi.siddhi.AnnotationElement;
import org.xtext.example.siddhi.siddhi.AnonymousStream;
import org.xtext.example.siddhi.siddhi.Attribute;
import org.xtext.example.siddhi.siddhi.AttributeIndex;
import org.xtext.example.siddhi.siddhi.AttributeList;
import org.xtext.example.siddhi.siddhi.AttributeNameReference;
import org.xtext.example.siddhi.siddhi.AttributeReference;
import org.xtext.example.siddhi.siddhi.AttributeType;
import org.xtext.example.siddhi.siddhi.BasicSource;
import org.xtext.example.siddhi.siddhi.BasicSourceStreamHandler;
import org.xtext.example.siddhi.siddhi.BasicSourceStreamHandlers;
import org.xtext.example.siddhi.siddhi.BasicSourceStreamHandlers1;
import org.xtext.example.siddhi.siddhi.BoolValue;
import org.xtext.example.siddhi.siddhi.Collect;
import org.xtext.example.siddhi.siddhi.ConditionRange;
import org.xtext.example.siddhi.siddhi.ConditionRanges;
import org.xtext.example.siddhi.siddhi.ConstantValue;
import org.xtext.example.siddhi.siddhi.D;
import org.xtext.example.siddhi.siddhi.DOUBLE_LITERAL;
import org.xtext.example.siddhi.siddhi.DayValue;
import org.xtext.example.siddhi.siddhi.DefinitionAggregation;
import org.xtext.example.siddhi.siddhi.DefinitionFunction;
import org.xtext.example.siddhi.siddhi.DefinitionStream;
import org.xtext.example.siddhi.siddhi.DefinitionTable;
import org.xtext.example.siddhi.siddhi.DefinitionTrigger;
import org.xtext.example.siddhi.siddhi.DefinitionWindow;
import org.xtext.example.siddhi.siddhi.E;
import org.xtext.example.siddhi.siddhi.EVERY;
import org.xtext.example.siddhi.siddhi.EveryAbsentPatternSource;
import org.xtext.example.siddhi.siddhi.EveryAbsentSequenceSourceChain;
import org.xtext.example.siddhi.siddhi.EveryPatternSourceChain;
import org.xtext.example.siddhi.siddhi.EverySequenceSourceChain;
import org.xtext.example.siddhi.siddhi.ExecPartition;
import org.xtext.example.siddhi.siddhi.ExecutionElement;
import org.xtext.example.siddhi.siddhi.ExecutionPlan;
import org.xtext.example.siddhi.siddhi.F;
import org.xtext.example.siddhi.siddhi.FLOAT_LITERAL;
import org.xtext.example.siddhi.siddhi.Features;
import org.xtext.example.siddhi.siddhi.FeaturesOrOutAttrReference;
import org.xtext.example.siddhi.siddhi.Filter;
import org.xtext.example.siddhi.siddhi.ForTime;
import org.xtext.example.siddhi.siddhi.FunctionBody;
import org.xtext.example.siddhi.siddhi.FunctionId;
import org.xtext.example.siddhi.siddhi.FunctionName;
import org.xtext.example.siddhi.siddhi.FunctionNamespace;
import org.xtext.example.siddhi.siddhi.FunctionOperation;
import org.xtext.example.siddhi.siddhi.GroupBy;
import org.xtext.example.siddhi.siddhi.GroupByQuerySelection;
import org.xtext.example.siddhi.siddhi.HavingExpr;
import org.xtext.example.siddhi.siddhi.HourValue;
import org.xtext.example.siddhi.siddhi.IN;
import org.xtext.example.siddhi.siddhi.JoinStream;
import org.xtext.example.siddhi.siddhi.Keyword;
import org.xtext.example.siddhi.siddhi.L;
import org.xtext.example.siddhi.siddhi.LONG_LITERAL;
import org.xtext.example.siddhi.siddhi.LanguageName;
import org.xtext.example.siddhi.siddhi.LeftAbsentPatternSource;
import org.xtext.example.siddhi.siddhi.LeftAbsentPatternSource1;
import org.xtext.example.siddhi.siddhi.LeftAbsentSequenceSource;
import org.xtext.example.siddhi.siddhi.LeftAbsentSequenceSource1;
import org.xtext.example.siddhi.siddhi.LogicalAbsentStatefulSource;
import org.xtext.example.siddhi.siddhi.LogicalStatefulSource;
import org.xtext.example.siddhi.siddhi.MainSource;
import org.xtext.example.siddhi.siddhi.MathAddsubOperation;
import org.xtext.example.siddhi.siddhi.MathDivmulOperation;
import org.xtext.example.siddhi.siddhi.MathEqualOperation;
import org.xtext.example.siddhi.siddhi.MathGtLtOperation;
import org.xtext.example.siddhi.siddhi.MathInOperation;
import org.xtext.example.siddhi.siddhi.MathLogicalOperation;
import org.xtext.example.siddhi.siddhi.MathOperation;
import org.xtext.example.siddhi.siddhi.MathOtherOperations1;
import org.xtext.example.siddhi.siddhi.MillisecondValue;
import org.xtext.example.siddhi.siddhi.MinuteValue;
import org.xtext.example.siddhi.siddhi.MonthValue;
import org.xtext.example.siddhi.siddhi.NOT;
import org.xtext.example.siddhi.siddhi.Name;
import org.xtext.example.siddhi.siddhi.NotOperation;
import org.xtext.example.siddhi.siddhi.NullCheck;
import org.xtext.example.siddhi.siddhi.OF;
import org.xtext.example.siddhi.siddhi.ON;
import org.xtext.example.siddhi.siddhi.OR;
import org.xtext.example.siddhi.siddhi.OutAttr;
import org.xtext.example.siddhi.siddhi.OutputAttribute;
import org.xtext.example.siddhi.siddhi.OutputEventType;
import org.xtext.example.siddhi.siddhi.OutputRate;
import org.xtext.example.siddhi.siddhi.OutputRateType;
import org.xtext.example.siddhi.siddhi.PatternSource;
import org.xtext.example.siddhi.siddhi.PatternSourceChain;
import org.xtext.example.siddhi.siddhi.Per1;
import org.xtext.example.siddhi.siddhi.PropertyName;
import org.xtext.example.siddhi.siddhi.PropertySeparator;
import org.xtext.example.siddhi.siddhi.PropertyValue;
import org.xtext.example.siddhi.siddhi.Query;
import org.xtext.example.siddhi.siddhi.QueryInput;
import org.xtext.example.siddhi.siddhi.QueryOutput;
import org.xtext.example.siddhi.siddhi.QuerySection;
import org.xtext.example.siddhi.siddhi.RightAbsentPatternSource;
import org.xtext.example.siddhi.siddhi.RightAbsentPatternSource1;
import org.xtext.example.siddhi.siddhi.RightAbsentSequenceSource;
import org.xtext.example.siddhi.siddhi.RightAbsentSequenceSource1;
import org.xtext.example.siddhi.siddhi.SecondValue;
import org.xtext.example.siddhi.siddhi.SequenceSourceChain;
import org.xtext.example.siddhi.siddhi.SequenceStream;
import org.xtext.example.siddhi.siddhi.SetClause;
import org.xtext.example.siddhi.siddhi.SiddhiPackage;
import org.xtext.example.siddhi.siddhi.SiddhiQL;
import org.xtext.example.siddhi.siddhi.Source;
import org.xtext.example.siddhi.siddhi.Source1;
import org.xtext.example.siddhi.siddhi.SourceOrEventReference;
import org.xtext.example.siddhi.siddhi.StandardStatefulSource;
import org.xtext.example.siddhi.siddhi.StreamAlias;
import org.xtext.example.siddhi.siddhi.StreamFunction;
import org.xtext.example.siddhi.siddhi.StreamReference;
import org.xtext.example.siddhi.siddhi.StringValue;
import org.xtext.example.siddhi.siddhi.TimeValue;
import org.xtext.example.siddhi.siddhi.TriggerName;
import org.xtext.example.siddhi.siddhi.UNIDIRECTIONAL;
import org.xtext.example.siddhi.siddhi.WeekValue;
import org.xtext.example.siddhi.siddhi.Win;
import org.xtext.example.siddhi.siddhi.WithinTime;
import org.xtext.example.siddhi.siddhi.WithinTimeRange;
import org.xtext.example.siddhi.siddhi.YearValue;
import org.xtext.example.siddhi.siddhi.aggregation_time_interval;
import org.xtext.example.siddhi.siddhi.joins;

@SuppressWarnings("all")
public class SiddhiSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SiddhiGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SiddhiPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SiddhiPackage.AND:
				sequence_AND(context, (AND) semanticObject); 
				return; 
			case SiddhiPackage.APP:
				if (rule == grammarAccess.getAPPRule()) {
					sequence_APP(context, (APP) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAppAnnotationRule()) {
					sequence_APP_AppAnnotation(context, (APP) semanticObject); 
					return; 
				}
				else break;
			case SiddhiPackage.AS:
				sequence_AS(context, (AS) semanticObject); 
				return; 
			case SiddhiPackage.ABSENT_PATTERN_SOURCE_CHAIN:
				sequence_AbsentPatternSourceChain(context, (AbsentPatternSourceChain) semanticObject); 
				return; 
			case SiddhiPackage.ABSENT_SEQUENCE_SOURCE_CHAIN:
				sequence_AbsentSequenceSourceChain(context, (AbsentSequenceSourceChain) semanticObject); 
				return; 
			case SiddhiPackage.AGGREGATION_TIME_DURATION:
				sequence_DAYS_HOURS_MINUTES_MONTHS_SECONDS_WEEKS_YEARS(context, (AggregationTimeDuration) semanticObject); 
				return; 
			case SiddhiPackage.AGGREGATION_TIME_RANGE:
				sequence_AggregationTimeRange(context, (AggregationTimeRange) semanticObject); 
				return; 
			case SiddhiPackage.ANNOTATION:
				sequence_Annotation(context, (Annotation) semanticObject); 
				return; 
			case SiddhiPackage.ANNOTATION_ELEMENT:
				sequence_AnnotationElement(context, (AnnotationElement) semanticObject); 
				return; 
			case SiddhiPackage.ANONYMOUS_STREAM:
				sequence_AnonymousStream_FROM_RETURN(context, (AnonymousStream) semanticObject); 
				return; 
			case SiddhiPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case SiddhiPackage.ATTRIBUTE_INDEX:
				sequence_AttributeIndex_LAST(context, (AttributeIndex) semanticObject); 
				return; 
			case SiddhiPackage.ATTRIBUTE_LIST:
				sequence_AttributeList(context, (AttributeList) semanticObject); 
				return; 
			case SiddhiPackage.ATTRIBUTE_NAME_REFERENCE:
				sequence_AttributeNameReference(context, (AttributeNameReference) semanticObject); 
				return; 
			case SiddhiPackage.ATTRIBUTE_REFERENCE:
				if (rule == grammarAccess.getAttributeReferenceRule()) {
					sequence_AttributeReference(context, (AttributeReference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSetAssignmentRule()) {
					sequence_AttributeReference_SetAssignment(context, (AttributeReference) semanticObject); 
					return; 
				}
				else break;
			case SiddhiPackage.ATTRIBUTE_TYPE:
				sequence_AttributeType_BOOL_DOUBLE_FLOAT_INTS_LONG_OBJECT_STRINGS(context, (AttributeType) semanticObject); 
				return; 
			case SiddhiPackage.BASIC_SOURCE:
				sequence_BasicSource(context, (BasicSource) semanticObject); 
				return; 
			case SiddhiPackage.BASIC_SOURCE_STREAM_HANDLER:
				sequence_BasicSourceStreamHandler(context, (BasicSourceStreamHandler) semanticObject); 
				return; 
			case SiddhiPackage.BASIC_SOURCE_STREAM_HANDLERS:
				sequence_BasicSourceStreamHandlers(context, (BasicSourceStreamHandlers) semanticObject); 
				return; 
			case SiddhiPackage.BASIC_SOURCE_STREAM_HANDLERS1:
				sequence_BasicSourceStreamHandlers1_WINDOW(context, (BasicSourceStreamHandlers1) semanticObject); 
				return; 
			case SiddhiPackage.BOOL_VALUE:
				sequence_FALSE_TRUE(context, (BoolValue) semanticObject); 
				return; 
			case SiddhiPackage.COLLECT:
				sequence_Collect(context, (Collect) semanticObject); 
				return; 
			case SiddhiPackage.CONDITION_RANGE:
				sequence_ConditionRange(context, (ConditionRange) semanticObject); 
				return; 
			case SiddhiPackage.CONDITION_RANGES:
				if (rule == grammarAccess.getConditionRangesRule()) {
					sequence_ConditionRanges(context, (ConditionRanges) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPartitionWithStreamRule()) {
					sequence_ConditionRanges_PartitionWithStream(context, (ConditionRanges) semanticObject); 
					return; 
				}
				else break;
			case SiddhiPackage.CONSTANT_VALUE:
				sequence_ConstantValue(context, (ConstantValue) semanticObject); 
				return; 
			case SiddhiPackage.D:
				sequence_D(context, (D) semanticObject); 
				return; 
			case SiddhiPackage.DOUBLE_LITERAL:
				sequence_DOUBLE_LITERAL(context, (DOUBLE_LITERAL) semanticObject); 
				return; 
			case SiddhiPackage.DAY_VALUE:
				sequence_DAYS(context, (DayValue) semanticObject); 
				return; 
			case SiddhiPackage.DEFINITION_AGGREGATION:
				sequence_AGGREGATE_AGGREGATION_BY_DEFINE_DefinitionAggregation_FROM(context, (DefinitionAggregation) semanticObject); 
				return; 
			case SiddhiPackage.DEFINITION_FUNCTION:
				sequence_DEFINE_DefinitionFunction_FUNCTION_RETURN(context, (DefinitionFunction) semanticObject); 
				return; 
			case SiddhiPackage.DEFINITION_STREAM:
				sequence_DEFINE_DefinitionStream_STREAM_TABLE(context, (DefinitionStream) semanticObject); 
				return; 
			case SiddhiPackage.DEFINITION_TABLE:
				sequence_DEFINE_DefinitionTable_TABLE(context, (DefinitionTable) semanticObject); 
				return; 
			case SiddhiPackage.DEFINITION_TRIGGER:
				sequence_AT_DEFINE_DefinitionTrigger_TRIGGER(context, (DefinitionTrigger) semanticObject); 
				return; 
			case SiddhiPackage.DEFINITION_WINDOW:
				sequence_DEFINE_DefinitionWindow_OUTPUT_WINDOW(context, (DefinitionWindow) semanticObject); 
				return; 
			case SiddhiPackage.E:
				sequence_E(context, (E) semanticObject); 
				return; 
			case SiddhiPackage.EVERY:
				if (rule == grammarAccess.getPatternStreamRule()
						|| rule == grammarAccess.getAbsentPatternSourceChainRule()) {
					sequence_AbsentPatternSourceChain_EVERY_EveryAbsentPatternSource_LeftAbsentPatternSource2_RightAbsentPatternSource2(context, (EVERY) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEVERYRule()) {
					sequence_EVERY(context, (EVERY) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEveryAbsentPatternSourceRule()) {
					sequence_EVERY_EveryAbsentPatternSource(context, (EVERY) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEveryAbsentSequenceSourceChainRule()) {
					sequence_EVERY_EveryAbsentSequenceSourceChain(context, (EVERY) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEverySequenceSourceChainRule()) {
					sequence_EVERY_EverySequenceSourceChain(context, (EVERY) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLeftAbsentPatternSourceRule()
						|| action == grammarAccess.getLeftAbsentPatternSourceAccess().getLeftAbsentPatternSourceLeftAction_1_0_0()
						|| rule == grammarAccess.getLeftAbsentPatternSource1Rule()
						|| action == grammarAccess.getLeftAbsentPatternSource1Access().getLeftAbsentPatternSource1LeftAction_1_0_0()
						|| rule == grammarAccess.getLeftAbsentPatternSource2Rule()) {
					sequence_EVERY_LeftAbsentPatternSource2(context, (EVERY) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRightAbsentPatternSourceRule()
						|| action == grammarAccess.getRightAbsentPatternSourceAccess().getRightAbsentPatternSourceLeft1Action_1_0_0()
						|| rule == grammarAccess.getRightAbsentPatternSource1Rule()
						|| action == grammarAccess.getRightAbsentPatternSource1Access().getRightAbsentPatternSource1LeftAction_1_0_0()
						|| rule == grammarAccess.getRightAbsentPatternSource2Rule()) {
					sequence_EVERY_RightAbsentPatternSource2(context, (EVERY) semanticObject); 
					return; 
				}
				else break;
			case SiddhiPackage.EVERY_ABSENT_PATTERN_SOURCE:
				sequence_EveryAbsentPatternSource(context, (EveryAbsentPatternSource) semanticObject); 
				return; 
			case SiddhiPackage.EVERY_ABSENT_SEQUENCE_SOURCE_CHAIN:
				sequence_EveryAbsentSequenceSourceChain(context, (EveryAbsentSequenceSourceChain) semanticObject); 
				return; 
			case SiddhiPackage.EVERY_PATTERN_SOURCE_CHAIN:
				if (rule == grammarAccess.getEveryPatternSourceChain1Rule()) {
					sequence_EveryPatternSourceChain1(context, (EveryPatternSourceChain) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPatternStreamRule()
						|| rule == grammarAccess.getEveryPatternSourceChainRule()
						|| action == grammarAccess.getEveryPatternSourceChainAccess().getEveryPatternSourceChainLeftAction_1_0_0()) {
					sequence_EveryPatternSourceChain_EveryPatternSourceChain1(context, (EveryPatternSourceChain) semanticObject); 
					return; 
				}
				else break;
			case SiddhiPackage.EVERY_SEQUENCE_SOURCE_CHAIN:
				sequence_EverySequenceSourceChain(context, (EverySequenceSourceChain) semanticObject); 
				return; 
			case SiddhiPackage.EXEC_PARTITION:
				sequence_BEGIN_END_ExecPartition_PARTITION_WITH(context, (ExecPartition) semanticObject); 
				return; 
			case SiddhiPackage.EXECUTION_ELEMENT:
				sequence_ExecutionElement(context, (ExecutionElement) semanticObject); 
				return; 
			case SiddhiPackage.EXECUTION_PLAN:
				sequence_ExecutionPlan(context, (ExecutionPlan) semanticObject); 
				return; 
			case SiddhiPackage.F:
				sequence_F(context, (F) semanticObject); 
				return; 
			case SiddhiPackage.FLOAT_LITERAL:
				sequence_FLOAT_LITERAL(context, (FLOAT_LITERAL) semanticObject); 
				return; 
			case SiddhiPackage.FEATURES:
				sequence_Features(context, (Features) semanticObject); 
				return; 
			case SiddhiPackage.FEATURES_OR_OUT_ATTR_REFERENCE:
				sequence_FeaturesOrOutAttrReference(context, (FeaturesOrOutAttrReference) semanticObject); 
				return; 
			case SiddhiPackage.FILTER:
				sequence_Filter(context, (Filter) semanticObject); 
				return; 
			case SiddhiPackage.FOR_TIME:
				sequence_FOR_ForTime(context, (ForTime) semanticObject); 
				return; 
			case SiddhiPackage.FUNCTION_BODY:
				sequence_FunctionBody(context, (FunctionBody) semanticObject); 
				return; 
			case SiddhiPackage.FUNCTION_ID:
				sequence_FunctionId(context, (FunctionId) semanticObject); 
				return; 
			case SiddhiPackage.FUNCTION_NAME:
				sequence_FunctionName(context, (FunctionName) semanticObject); 
				return; 
			case SiddhiPackage.FUNCTION_NAMESPACE:
				sequence_FunctionNamespace(context, (FunctionNamespace) semanticObject); 
				return; 
			case SiddhiPackage.FUNCTION_OPERATION:
				sequence_FunctionOperation(context, (FunctionOperation) semanticObject); 
				return; 
			case SiddhiPackage.GROUP_BY:
				sequence_BY_GROUP_GroupBy(context, (GroupBy) semanticObject); 
				return; 
			case SiddhiPackage.GROUP_BY_QUERY_SELECTION:
				sequence_GroupByQuerySelection_SELECT(context, (GroupByQuerySelection) semanticObject); 
				return; 
			case SiddhiPackage.HAVING_EXPR:
				sequence_HAVING_HavingExpr(context, (HavingExpr) semanticObject); 
				return; 
			case SiddhiPackage.HOUR_VALUE:
				sequence_HOURS(context, (HourValue) semanticObject); 
				return; 
			case SiddhiPackage.IN:
				sequence_IN(context, (IN) semanticObject); 
				return; 
			case SiddhiPackage.JOIN_STREAM:
				sequence_JoinStream(context, (JoinStream) semanticObject); 
				return; 
			case SiddhiPackage.KEYWORD:
				sequence_ALL_BEGIN_BOOL_BY_CURRENT_DAYS_DEFINE_DELETE_DOUBLE_END_EVENTS_EXPIRED_FALSE_FIRST_FLOAT_FOR_FROM_FULL_GROUP_HAVING_HOURS_INNER_INSERT_INTO_INTS_IS_JOIN_Keyword_LAST_LEFT_LONG_MILLISECONDS_MINUTES_MONTHS_NULL_OBJECT_OUTER_OUTPUT_PARTITION_RAW_RETURN_RIGHT_SECONDS_SELECT_SNAPSHOT_STREAM_STRINGS_TABLE_TRUE_UPDATE_WEEKS_WINDOW_WITH_WITHIN_YEARS(context, (Keyword) semanticObject); 
				return; 
			case SiddhiPackage.L:
				sequence_L(context, (L) semanticObject); 
				return; 
			case SiddhiPackage.LONG_LITERAL:
				sequence_LONG_LITERAL(context, (LONG_LITERAL) semanticObject); 
				return; 
			case SiddhiPackage.LANGUAGE_NAME:
				sequence_LanguageName(context, (LanguageName) semanticObject); 
				return; 
			case SiddhiPackage.LEFT_ABSENT_PATTERN_SOURCE:
				if (rule == grammarAccess.getLeftAbsentPatternSource1Rule()
						|| action == grammarAccess.getLeftAbsentPatternSource1Access().getLeftAbsentPatternSource1LeftAction_1_0_0()
						|| rule == grammarAccess.getLeftAbsentPatternSource2Rule()) {
					sequence_LeftAbsentPatternSource2(context, (LeftAbsentPatternSource) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPatternStreamRule()
						|| rule == grammarAccess.getAbsentPatternSourceChainRule()
						|| rule == grammarAccess.getLeftAbsentPatternSourceRule()
						|| action == grammarAccess.getLeftAbsentPatternSourceAccess().getLeftAbsentPatternSourceLeftAction_1_0_0()) {
					sequence_LeftAbsentPatternSource_LeftAbsentPatternSource2(context, (LeftAbsentPatternSource) semanticObject); 
					return; 
				}
				else break;
			case SiddhiPackage.LEFT_ABSENT_PATTERN_SOURCE1:
				sequence_LeftAbsentPatternSource1(context, (LeftAbsentPatternSource1) semanticObject); 
				return; 
			case SiddhiPackage.LEFT_ABSENT_SEQUENCE_SOURCE:
				if (rule == grammarAccess.getLeftAbsentSequenceSource1Rule()
						|| action == grammarAccess.getLeftAbsentSequenceSource1Access().getLeftAbsentSequenceSource1LeftAction_1_0_0()
						|| rule == grammarAccess.getLeftAbsentSequenceSource2Rule()) {
					sequence_LeftAbsentSequenceSource2(context, (LeftAbsentSequenceSource) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLeftAbsentSequenceSourceRule()
						|| action == grammarAccess.getLeftAbsentSequenceSourceAccess().getLeftAbsentSequenceSourceLeftAction_1_0_0()) {
					sequence_LeftAbsentSequenceSource_LeftAbsentSequenceSource2(context, (LeftAbsentSequenceSource) semanticObject); 
					return; 
				}
				else break;
			case SiddhiPackage.LEFT_ABSENT_SEQUENCE_SOURCE1:
				sequence_LeftAbsentSequenceSource1(context, (LeftAbsentSequenceSource1) semanticObject); 
				return; 
			case SiddhiPackage.LOGICAL_ABSENT_STATEFUL_SOURCE:
				if (rule == grammarAccess.getLogicalAbsentStatefulSourceRule()
						|| rule == grammarAccess.getSequenceSourceRule()) {
					sequence_LogicalAbsentStatefulSource(context, (LogicalAbsentStatefulSource) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSequenceSourceChainRule()
						|| action == grammarAccess.getSequenceSourceChainAccess().getSequenceSourceChainLeftAction_1_0_0()
						|| rule == grammarAccess.getSequenceSourceChain1Rule()) {
					sequence_LogicalAbsentStatefulSource_SequenceSourceChain1(context, (LogicalAbsentStatefulSource) semanticObject); 
					return; 
				}
				else break;
			case SiddhiPackage.LOGICAL_STATEFUL_SOURCE:
				if (rule == grammarAccess.getLogicalStatefulSourceRule()
						|| rule == grammarAccess.getSequenceSourceRule()) {
					sequence_LogicalStatefulSource(context, (LogicalStatefulSource) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSequenceSourceChainRule()
						|| action == grammarAccess.getSequenceSourceChainAccess().getSequenceSourceChainLeftAction_1_0_0()
						|| rule == grammarAccess.getSequenceSourceChain1Rule()) {
					sequence_LogicalStatefulSource_SequenceSourceChain1(context, (LogicalStatefulSource) semanticObject); 
					return; 
				}
				else break;
			case SiddhiPackage.MAIN_SOURCE:
				if (rule == grammarAccess.getJoinSourceRule()) {
					sequence_JoinSource_MainSource(context, (MainSource) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMainSourceRule()) {
					sequence_MainSource(context, (MainSource) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJoinStreamRule()
						|| rule == grammarAccess.getStandardStreamRule()) {
					sequence_MainSource_StandardStream(context, (MainSource) semanticObject); 
					return; 
				}
				else break;
			case SiddhiPackage.MATH_ADDSUB_OPERATION:
				sequence_MathAddsubOperation(context, (MathAddsubOperation) semanticObject); 
				return; 
			case SiddhiPackage.MATH_DIVMUL_OPERATION:
				sequence_MathDivmulOperation(context, (MathDivmulOperation) semanticObject); 
				return; 
			case SiddhiPackage.MATH_EQUAL_OPERATION:
				sequence_MathEqualOperation(context, (MathEqualOperation) semanticObject); 
				return; 
			case SiddhiPackage.MATH_GT_LT_OPERATION:
				sequence_MathGtLtOperation(context, (MathGtLtOperation) semanticObject); 
				return; 
			case SiddhiPackage.MATH_IN_OPERATION:
				sequence_MathInOperation(context, (MathInOperation) semanticObject); 
				return; 
			case SiddhiPackage.MATH_LOGICAL_OPERATION:
				sequence_MathLogicalOperation(context, (MathLogicalOperation) semanticObject); 
				return; 
			case SiddhiPackage.MATH_OPERATION:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getMathOperationRule()) {
					sequence_MathOperation(context, (MathOperation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMathLogicalOperationRule()
						|| action == grammarAccess.getMathLogicalOperationAccess().getMathLogicalOperationLeftAction_1_0_0()
						|| rule == grammarAccess.getMathInOperationRule()
						|| action == grammarAccess.getMathInOperationAccess().getMathInOperationLeftAction_1_0_0()
						|| rule == grammarAccess.getMathGtLtOperationRule()
						|| action == grammarAccess.getMathGtLtOperationAccess().getMathGtLtOperationLeftAction_1_0_0()
						|| rule == grammarAccess.getMathEqualOperationRule()
						|| action == grammarAccess.getMathEqualOperationAccess().getMathEqualOperationLeftAction_1_0_0()
						|| rule == grammarAccess.getMathAddsubOperationRule()
						|| action == grammarAccess.getMathAddsubOperationAccess().getMathAddsubOperationLeftAction_1_0_0()
						|| rule == grammarAccess.getMathDivmulOperationRule()
						|| action == grammarAccess.getMathDivmulOperationAccess().getMathDivmulOperationLeftAction_1_0_0()
						|| rule == grammarAccess.getMathOtherOperationsRule()) {
					sequence_MathOtherOperations(context, (MathOperation) semanticObject); 
					return; 
				}
				else break;
			case SiddhiPackage.MATH_OTHER_OPERATIONS1:
				sequence_MathOtherOperations1(context, (MathOtherOperations1) semanticObject); 
				return; 
			case SiddhiPackage.MILLISECOND_VALUE:
				sequence_MILLISECONDS(context, (MillisecondValue) semanticObject); 
				return; 
			case SiddhiPackage.MINUTE_VALUE:
				sequence_MINUTES(context, (MinuteValue) semanticObject); 
				return; 
			case SiddhiPackage.MONTH_VALUE:
				sequence_MONTHS(context, (MonthValue) semanticObject); 
				return; 
			case SiddhiPackage.NOT:
				if (rule == grammarAccess.getBasicAbsentPatternSourceRule()) {
					sequence_BasicAbsentPatternSource_NOT(context, (NOT) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLogicalAbsentStatefulSourceRule()
						|| rule == grammarAccess.getSequenceSourceRule()) {
					sequence_LogicalAbsentStatefulSource_NOT(context, (NOT) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSequenceSourceChainRule()
						|| action == grammarAccess.getSequenceSourceChainAccess().getSequenceSourceChainLeftAction_1_0_0()
						|| rule == grammarAccess.getSequenceSourceChain1Rule()) {
					sequence_LogicalAbsentStatefulSource_NOT_SequenceSourceChain1(context, (NOT) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNOTRule()) {
					sequence_NOT(context, (NOT) semanticObject); 
					return; 
				}
				else break;
			case SiddhiPackage.NAME:
				sequence_Name(context, (Name) semanticObject); 
				return; 
			case SiddhiPackage.NOT_OPERATION:
				sequence_MathOtherOperations(context, (NotOperation) semanticObject); 
				return; 
			case SiddhiPackage.NULL_CHECK:
				sequence_IS_NULL_NullCheck(context, (NullCheck) semanticObject); 
				return; 
			case SiddhiPackage.OF:
				sequence_OF(context, (OF) semanticObject); 
				return; 
			case SiddhiPackage.ON:
				sequence_ON(context, (ON) semanticObject); 
				return; 
			case SiddhiPackage.OR:
				sequence_OR(context, (OR) semanticObject); 
				return; 
			case SiddhiPackage.OUT_ATTR:
				sequence_OutAttr(context, (OutAttr) semanticObject); 
				return; 
			case SiddhiPackage.OUTPUT_ATTRIBUTE:
				sequence_OutputAttribute(context, (OutputAttribute) semanticObject); 
				return; 
			case SiddhiPackage.OUTPUT_EVENT_TYPE:
				sequence_ALL_CURRENT_EVENTS_EXPIRED_OutputEventType_RAW(context, (OutputEventType) semanticObject); 
				return; 
			case SiddhiPackage.OUTPUT_RATE:
				sequence_EVENTS_OUTPUT_OutputRate_SNAPSHOT(context, (OutputRate) semanticObject); 
				return; 
			case SiddhiPackage.OUTPUT_RATE_TYPE:
				sequence_ALL_FIRST_LAST_OutputRateType(context, (OutputRateType) semanticObject); 
				return; 
			case SiddhiPackage.PATTERN_SOURCE:
				sequence_PatternSource(context, (PatternSource) semanticObject); 
				return; 
			case SiddhiPackage.PATTERN_SOURCE_CHAIN:
				if (rule == grammarAccess.getPatternSourceChain1Rule()) {
					sequence_PatternSourceChain1(context, (PatternSourceChain) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPatternSourceChainRule()
						|| action == grammarAccess.getPatternSourceChainAccess().getPatternSourceChainLeftAction_1_0_0()) {
					sequence_PatternSourceChain_PatternSourceChain1(context, (PatternSourceChain) semanticObject); 
					return; 
				}
				else break;
			case SiddhiPackage.PER1:
				sequence_PER_Per1(context, (Per1) semanticObject); 
				return; 
			case SiddhiPackage.PROPERTY_NAME:
				sequence_PropertyName(context, (PropertyName) semanticObject); 
				return; 
			case SiddhiPackage.PROPERTY_SEPARATOR:
				sequence_PropertySeparator(context, (PropertySeparator) semanticObject); 
				return; 
			case SiddhiPackage.PROPERTY_VALUE:
				sequence_PropertyValue(context, (PropertyValue) semanticObject); 
				return; 
			case SiddhiPackage.QUERY:
				sequence_FROM_Query(context, (Query) semanticObject); 
				return; 
			case SiddhiPackage.QUERY_INPUT:
				sequence_QueryInput(context, (QueryInput) semanticObject); 
				return; 
			case SiddhiPackage.QUERY_OUTPUT:
				sequence_DELETE_FOR_INSERT_INTO_QueryOutput_RETURN_UPDATE(context, (QueryOutput) semanticObject); 
				return; 
			case SiddhiPackage.QUERY_SECTION:
				sequence_QuerySection(context, (QuerySection) semanticObject); 
				return; 
			case SiddhiPackage.RIGHT_ABSENT_PATTERN_SOURCE:
				if (rule == grammarAccess.getRightAbsentPatternSource1Rule()
						|| action == grammarAccess.getRightAbsentPatternSource1Access().getRightAbsentPatternSource1LeftAction_1_0_0()
						|| rule == grammarAccess.getRightAbsentPatternSource2Rule()) {
					sequence_RightAbsentPatternSource2(context, (RightAbsentPatternSource) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPatternStreamRule()
						|| rule == grammarAccess.getAbsentPatternSourceChainRule()
						|| rule == grammarAccess.getRightAbsentPatternSourceRule()
						|| action == grammarAccess.getRightAbsentPatternSourceAccess().getRightAbsentPatternSourceLeft1Action_1_0_0()) {
					sequence_RightAbsentPatternSource_RightAbsentPatternSource2(context, (RightAbsentPatternSource) semanticObject); 
					return; 
				}
				else break;
			case SiddhiPackage.RIGHT_ABSENT_PATTERN_SOURCE1:
				sequence_RightAbsentPatternSource1(context, (RightAbsentPatternSource1) semanticObject); 
				return; 
			case SiddhiPackage.RIGHT_ABSENT_SEQUENCE_SOURCE:
				if (rule == grammarAccess.getRightAbsentSequenceSource1Rule()
						|| action == grammarAccess.getRightAbsentSequenceSource1Access().getRightAbsentSequenceSource1LeftAction_1_0_0()
						|| rule == grammarAccess.getRightAbsentSequenceSource2Rule()) {
					sequence_RightAbsentSequenceSource2(context, (RightAbsentSequenceSource) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRightAbsentSequenceSourceRule()
						|| action == grammarAccess.getRightAbsentSequenceSourceAccess().getRightAbsentSequenceSourceLeft1Action_1_0_0()) {
					sequence_RightAbsentSequenceSource_RightAbsentSequenceSource2(context, (RightAbsentSequenceSource) semanticObject); 
					return; 
				}
				else break;
			case SiddhiPackage.RIGHT_ABSENT_SEQUENCE_SOURCE1:
				sequence_RightAbsentSequenceSource1(context, (RightAbsentSequenceSource1) semanticObject); 
				return; 
			case SiddhiPackage.SECOND_VALUE:
				sequence_SECONDS(context, (SecondValue) semanticObject); 
				return; 
			case SiddhiPackage.SEQUENCE_SOURCE_CHAIN:
				sequence_SequenceSourceChain_SequenceSourceChain1(context, (SequenceSourceChain) semanticObject); 
				return; 
			case SiddhiPackage.SEQUENCE_STREAM:
				sequence_SequenceStream(context, (SequenceStream) semanticObject); 
				return; 
			case SiddhiPackage.SET_CLAUSE:
				sequence_SET_SetClause(context, (SetClause) semanticObject); 
				return; 
			case SiddhiPackage.SIDDHI_QL:
				sequence_SiddhiQL(context, (SiddhiQL) semanticObject); 
				return; 
			case SiddhiPackage.SOURCE:
				sequence_Source(context, (Source) semanticObject); 
				return; 
			case SiddhiPackage.SOURCE1:
				sequence_Source1(context, (Source1) semanticObject); 
				return; 
			case SiddhiPackage.SOURCE_OR_EVENT_REFERENCE:
				sequence_SourceOrEventReference(context, (SourceOrEventReference) semanticObject); 
				return; 
			case SiddhiPackage.STANDARD_STATEFUL_SOURCE:
				if (rule == grammarAccess.getPatternCollectionStatefulSourceRule()) {
					sequence_PatternCollectionStatefulSource_StandardStatefulSource(context, (StandardStatefulSource) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSequenceSourceChainRule()
						|| action == grammarAccess.getSequenceSourceChainAccess().getSequenceSourceChainLeftAction_1_0_0()
						|| rule == grammarAccess.getSequenceSourceChain1Rule()) {
					sequence_SequenceCollectionStatefulSource_SequenceSourceChain1_StandardStatefulSource(context, (StandardStatefulSource) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSequenceSourceRule()) {
					sequence_SequenceCollectionStatefulSource_StandardStatefulSource(context, (StandardStatefulSource) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSequenceCollectionStatefulSourceRule()) {
					sequence_SequenceCollectionStatefulSource_StandardStatefulSource(context, (StandardStatefulSource) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStandardStatefulSourceRule()
						|| rule == grammarAccess.getSource1OrStandardStatefulSourceRule()) {
					sequence_StandardStatefulSource(context, (StandardStatefulSource) semanticObject); 
					return; 
				}
				else break;
			case SiddhiPackage.STREAM_ALIAS:
				sequence_StreamAlias(context, (StreamAlias) semanticObject); 
				return; 
			case SiddhiPackage.STREAM_FUNCTION:
				sequence_StreamFunction(context, (StreamFunction) semanticObject); 
				return; 
			case SiddhiPackage.STREAM_REFERENCE:
				sequence_StreamReference(context, (StreamReference) semanticObject); 
				return; 
			case SiddhiPackage.STRING_VALUE:
				sequence_StringValue(context, (StringValue) semanticObject); 
				return; 
			case SiddhiPackage.TIME_VALUE:
				sequence_TimeValue(context, (TimeValue) semanticObject); 
				return; 
			case SiddhiPackage.TRIGGER_NAME:
				sequence_TriggerName(context, (TriggerName) semanticObject); 
				return; 
			case SiddhiPackage.UNIDIRECTIONAL:
				sequence_UNIDIRECTIONAL(context, (UNIDIRECTIONAL) semanticObject); 
				return; 
			case SiddhiPackage.WEEK_VALUE:
				sequence_WEEKS(context, (WeekValue) semanticObject); 
				return; 
			case SiddhiPackage.WIN:
				sequence_WINDOW_Win(context, (Win) semanticObject); 
				return; 
			case SiddhiPackage.WITHIN_TIME:
				sequence_WITHIN_WithinTime(context, (WithinTime) semanticObject); 
				return; 
			case SiddhiPackage.WITHIN_TIME_RANGE:
				sequence_WITHIN_WithinTimeRange(context, (WithinTimeRange) semanticObject); 
				return; 
			case SiddhiPackage.YEAR_VALUE:
				sequence_YEARS(context, (YearValue) semanticObject); 
				return; 
			case SiddhiPackage.AGGREGATION_TIME_INTERVAL:
				sequence_aggregation_time_interval(context, (aggregation_time_interval) semanticObject); 
				return; 
			case SiddhiPackage.JOINS:
				sequence_FULL_INNER_JOIN_LEFT_OUTER_RIGHT_joins(context, (joins) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     DefinitionAggregation returns DefinitionAggregation
	 *
	 * Constraint:
	 *     (
	 *         ann+=Annotation* 
	 *         define='define' 
	 *         aggre='aggregation' 
	 *         src=Source1 
	 *         from='from' 
	 *         stdStream=StandardStream 
	 *         groupByQuerySel=GroupByQuerySelection 
	 *         agrregate='aggregate' 
	 *         (by='by' attrRef=AttributeReference)? 
	 *         eve=EVERY 
	 *         aggrTime=AggregationTime
	 *     )
	 */
	protected void sequence_AGGREGATE_AGGREGATION_BY_DEFINE_DefinitionAggregation_FROM(ISerializationContext context, DefinitionAggregation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Keyword returns Keyword
	 *
	 * Constraint:
	 *     (
	 *         a=AS | 
	 *         every=EVERY | 
	 *         uni=UNIDIRECTIONAL | 
	 *         on=ON | 
	 *         and=AND | 
	 *         or=OR | 
	 *         not=NOT | 
	 *         of=OF | 
	 *         str='stream' | 
	 *         define='define' | 
	 *         table='table' | 
	 *         window='window' | 
	 *         output='output' | 
	 *         string='string' | 
	 *         int='int' | 
	 *         long='long' | 
	 *         double='double' | 
	 *         float='float' | 
	 *         bool='bool' | 
	 *         object='object' | 
	 *         all='all' | 
	 *         events='events' | 
	 *         raw='raw' | 
	 *         expired='expired' | 
	 *         currt='current' | 
	 *         last='last' | 
	 *         is='is' | 
	 *         null='null' | 
	 *         return='return' | 
	 *         from='from' | 
	 *         within='within' | 
	 *         left='left' | 
	 *         right='right' | 
	 *         full='full' | 
	 *         join='join' | 
	 *         inner='inner' | 
	 *         outer='outer' | 
	 *         select='select' | 
	 *         group='group' | 
	 *         by='by' | 
	 *         having='having' | 
	 *         snapshot='snapshot' | 
	 *         first='first' | 
	 *         insert='insert' | 
	 *         into='into' | 
	 *         begin='begin' | 
	 *         delete='delete' | 
	 *         for='for' | 
	 *         update='update' | 
	 *         end='end' | 
	 *         partition='partition' | 
	 *         wi='with' | 
	 *         year='year' | 
	 *         years='years' | 
	 *         month='month' | 
	 *         months='months' | 
	 *         week='week' | 
	 *         weeks='weeks' | 
	 *         day='day' | 
	 *         days='days' | 
	 *         hour='hour' | 
	 *         hours='hours' | 
	 *         minute='minute' | 
	 *         minutes='minutes' | 
	 *         min='min' | 
	 *         second='second' | 
	 *         seconds='seconds' | 
	 *         sec='sec' | 
	 *         millisecond='millisecond' | 
	 *         milliseconds='milliseconds' | 
	 *         millisec='millisec' | 
	 *         fals='false' | 
	 *         tr='true'
	 *     )
	 */
	protected void sequence_ALL_BEGIN_BOOL_BY_CURRENT_DAYS_DEFINE_DELETE_DOUBLE_END_EVENTS_EXPIRED_FALSE_FIRST_FLOAT_FOR_FROM_FULL_GROUP_HAVING_HOURS_INNER_INSERT_INTO_INTS_IS_JOIN_Keyword_LAST_LEFT_LONG_MILLISECONDS_MINUTES_MONTHS_NULL_OBJECT_OUTER_OUTPUT_PARTITION_RAW_RETURN_RIGHT_SECONDS_SELECT_SNAPSHOT_STREAM_STRINGS_TABLE_TRUE_UPDATE_WEEKS_WINDOW_WITH_WITHIN_YEARS(ISerializationContext context, Keyword semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutputEventType returns OutputEventType
	 *
	 * Constraint:
	 *     ((((all='all' | expired='expired') raw='raw'?) | currt='current')? events='events')
	 */
	protected void sequence_ALL_CURRENT_EVENTS_EXPIRED_OutputEventType_RAW(ISerializationContext context, OutputEventType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutputRateType returns OutputRateType
	 *
	 * Constraint:
	 *     (all='all' | last='last' | first='first')
	 */
	protected void sequence_ALL_FIRST_LAST_OutputRateType(ISerializationContext context, OutputRateType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AND returns AND
	 *
	 * Constraint:
	 *     and='and'
	 */
	protected void sequence_AND(ISerializationContext context, AND semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getAND_And()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getAND_And()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getANDAccess().getAndAndKeyword_0(), semanticObject.getAnd());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     APP returns APP
	 *
	 * Constraint:
	 *     ap='app'
	 */
	protected void sequence_APP(ISerializationContext context, APP semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getAPP_Ap()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getAPP_Ap()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAPPAccess().getApAppKeyword_0(), semanticObject.getAp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AppAnnotation returns APP
	 *
	 * Constraint:
	 *     (ap='app' na=Name (ann5+=AnnotationElement ann5+=AnnotationElement*)?)
	 */
	protected void sequence_APP_AppAnnotation(ISerializationContext context, APP semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AS returns AS
	 *
	 * Constraint:
	 *     a='as'
	 */
	protected void sequence_AS(ISerializationContext context, AS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getAS_A()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getAS_A()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getASAccess().getAAsKeyword_0(), semanticObject.getA());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DefinitionTrigger returns DefinitionTrigger
	 *
	 * Constraint:
	 *     (define='define' trigger='trigger' tn=TriggerName at='at' ((every=EVERY tv=TimeValue) | sv=StringValue))
	 */
	protected void sequence_AT_DEFINE_DefinitionTrigger_TRIGGER(ISerializationContext context, DefinitionTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternStream returns AbsentPatternSourceChain
	 *     AbsentPatternSourceChain returns AbsentPatternSourceChain
	 *
	 * Constraint:
	 *     (absentPatternSrcChain=AbsentPatternSourceChain wt1=WithinTime?)
	 */
	protected void sequence_AbsentPatternSourceChain(ISerializationContext context, AbsentPatternSourceChain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternStream returns EVERY
	 *     AbsentPatternSourceChain returns EVERY
	 *
	 * Constraint:
	 *     (
	 *         every='every' 
	 *         (
	 *             (absentPatternSrcChain=AbsentPatternSourceChain wt1=WithinTime?) | 
	 *             basicAbsentPS=BasicAbsentPatternSource | 
	 *             (leftAbsPS=LeftAbsentPatternSource wt2+=WithinTime?) | 
	 *             (rightAbsPS=RightAbsentPatternSource wt3+=WithinTime?)
	 *         )
	 *     )
	 */
	protected void sequence_AbsentPatternSourceChain_EVERY_EveryAbsentPatternSource_LeftAbsentPatternSource2_RightAbsentPatternSource2(ISerializationContext context, EVERY semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbsentSequenceSourceChain returns AbsentSequenceSourceChain
	 *
	 * Constraint:
	 *     (
	 *         (absentSequenceSourceChain=AbsentSequenceSourceChain wt5=WithinTime?) | 
	 *         basicAbsentPatternSource=BasicAbsentPatternSource | 
	 *         leftAbsentSequenceSource=LeftAbsentSequenceSource | 
	 *         rightAbsentSequenceSource=RightAbsentSequenceSource
	 *     )
	 */
	protected void sequence_AbsentSequenceSourceChain(ISerializationContext context, AbsentSequenceSourceChain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AggregationTime returns AggregationTimeRange
	 *     AggregationTimeRange returns AggregationTimeRange
	 *
	 * Constraint:
	 *     (aggrtimeDur+=AggregationTimeDuration aggrtimeDur+=AggregationTimeDuration)
	 */
	protected void sequence_AggregationTimeRange(ISerializationContext context, AggregationTimeRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnnotationElement returns AnnotationElement
	 *
	 * Constraint:
	 *     (propName=PropertyName? propVal=PropertyValue)
	 */
	protected void sequence_AnnotationElement(ISerializationContext context, AnnotationElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Annotation returns Annotation
	 *
	 * Constraint:
	 *     (na=Name (annElement+=AnnotationElement | ann+=Annotation) annElement+=AnnotationElement? (ann+=Annotation? annElement+=AnnotationElement?)*)
	 */
	protected void sequence_Annotation(ISerializationContext context, Annotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnonymousStream returns AnonymousStream
	 *
	 * Constraint:
	 *     (
	 *         from='from' 
	 *         qi=QueryInput 
	 *         qs=QuerySection? 
	 *         out_rate=OutputRate? 
	 *         return='return' 
	 *         op_event_type=OutputEventType?
	 *     )
	 */
	protected void sequence_AnonymousStream_FROM_RETURN(ISerializationContext context, AnonymousStream semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeIndex returns AttributeIndex
	 *
	 * Constraint:
	 *     last='last'?
	 */
	protected void sequence_AttributeIndex_LAST(ISerializationContext context, AttributeIndex semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeList returns AttributeList
	 *
	 * Constraint:
	 *     (attr+=Attribute attr+=Attribute*)?
	 */
	protected void sequence_AttributeList(ISerializationContext context, AttributeList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeNameReference returns AttributeNameReference
	 *
	 * Constraint:
	 *     attrName1=[Features|IdNew]
	 */
	protected void sequence_AttributeNameReference(ISerializationContext context, AttributeNameReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getAttributeNameReference_AttrName1()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getAttributeNameReference_AttrName1()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeNameReferenceAccess().getAttrName1FeaturesIdNewParserRuleCall_0_1(), semanticObject.eGet(SiddhiPackage.eINSTANCE.getAttributeNameReference_AttrName1(), false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttributeReference returns AttributeReference
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             hash1='#'? 
	 *             name1=SourceOrEventReference 
	 *             attribute_index1=AttributeIndex? 
	 *             (hash2='#' name2=SourceOrEventReference attribute_index2=AttributeIndex?)? 
	 *             attr_name=AttributeNameReference
	 *         ) | 
	 *         featuresOrAttrRef=FeaturesOrOutAttrReference
	 *     )
	 */
	protected void sequence_AttributeReference(ISerializationContext context, AttributeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SetAssignment returns AttributeReference
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (
	 *                 hash1='#'? 
	 *                 name1=SourceOrEventReference 
	 *                 attribute_index1=AttributeIndex? 
	 *                 (hash2='#' name2=SourceOrEventReference attribute_index2=AttributeIndex?)? 
	 *                 attr_name=AttributeNameReference
	 *             ) | 
	 *             featuresOrAttrRef=FeaturesOrOutAttrReference
	 *         ) 
	 *         expression=Expression
	 *     )
	 */
	protected void sequence_AttributeReference_SetAssignment(ISerializationContext context, AttributeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeType returns AttributeType
	 *
	 * Constraint:
	 *     (
	 *         string='string' | 
	 *         int='int' | 
	 *         long='long' | 
	 *         double='double' | 
	 *         float='float' | 
	 *         bool='bool' | 
	 *         object='object'
	 *     )
	 */
	protected void sequence_AttributeType_BOOL_DOUBLE_FLOAT_INTS_LONG_OBJECT_STRINGS(ISerializationContext context, AttributeType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     mathOp=MathOperation
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getAttribute_MathOp()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getAttribute_MathOp()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeAccess().getMathOpMathOperationParserRuleCall_0(), semanticObject.getMathOp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExecPartition returns ExecPartition
	 *
	 * Constraint:
	 *     (
	 *         ann4+=Annotation* 
	 *         partition='partition' 
	 *         wi='with' 
	 *         partWithStream+=PartitionWithStream 
	 *         partWithStream+=PartitionWithStream* 
	 *         begin='begin' 
	 *         qu+=Query 
	 *         qu+=Query* 
	 *         end='end'
	 *     )
	 */
	protected void sequence_BEGIN_END_ExecPartition_PARTITION_WITH(ISerializationContext context, ExecPartition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GroupBy returns GroupBy
	 *
	 * Constraint:
	 *     (group='group' by='by' attr_ref+=AttributeReference attr_ref+=AttributeReference*)
	 */
	protected void sequence_BY_GROUP_GroupBy(ISerializationContext context, GroupBy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BasicAbsentPatternSource returns NOT
	 *
	 * Constraint:
	 *     (not1='not' basicSrc=BasicSource ft=ForTime)
	 */
	protected void sequence_BasicAbsentPatternSource_NOT(ISerializationContext context, NOT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getNOT_Not1()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getNOT_Not1()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getNOT_BasicSrc()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getNOT_BasicSrc()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getNOT_Ft()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getNOT_Ft()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNOTAccess().getNot1NotKeyword_0(), semanticObject.getNot1());
		feeder.accept(grammarAccess.getBasicAbsentPatternSourceAccess().getBasicSrcBasicSourceParserRuleCall_0_1_0(), semanticObject.getBasicSrc());
		feeder.accept(grammarAccess.getBasicAbsentPatternSourceAccess().getFtForTimeParserRuleCall_0_2_0(), semanticObject.getFt());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BasicSourceStreamHandler returns BasicSourceStreamHandler
	 *
	 * Constraint:
	 *     (fil=Filter | sf=StreamFunction)
	 */
	protected void sequence_BasicSourceStreamHandler(ISerializationContext context, BasicSourceStreamHandler semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BasicSourceStreamHandlers1 returns BasicSourceStreamHandlers1
	 *
	 * Constraint:
	 *     ((exp=Expression | fo=FunctionOperation)? (window='window' func_op=FunctionOperation)?)
	 */
	protected void sequence_BasicSourceStreamHandlers1_WINDOW(ISerializationContext context, BasicSourceStreamHandlers1 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BasicSourceStreamHandlers returns BasicSourceStreamHandlers
	 *
	 * Constraint:
	 *     basicSsHandler+=BasicSourceStreamHandler+
	 */
	protected void sequence_BasicSourceStreamHandlers(ISerializationContext context, BasicSourceStreamHandlers semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BasicSource returns BasicSource
	 *
	 * Constraint:
	 *     (src=Source basic_ss_handlers=BasicSourceStreamHandlers?)
	 */
	protected void sequence_BasicSource(ISerializationContext context, BasicSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Collect returns Collect
	 *
	 * Constraint:
	 *     ((start=INT_LITERAL end=INT_LITERAL) | start=INT_LITERAL | end=INT_LITERAL)?
	 */
	protected void sequence_Collect(ISerializationContext context, Collect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionRange returns ConditionRange
	 *
	 * Constraint:
	 *     (expr=Expression a=AS? sv=StringValue?)
	 */
	protected void sequence_ConditionRange(ISerializationContext context, ConditionRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionRanges returns ConditionRanges
	 *
	 * Constraint:
	 *     (conRange+=ConditionRange (or+=OR conRange+=ConditionRange)*)
	 */
	protected void sequence_ConditionRanges(ISerializationContext context, ConditionRanges semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PartitionWithStream returns ConditionRanges
	 *
	 * Constraint:
	 *     (conRange+=ConditionRange (or+=OR conRange+=ConditionRange)* of=OF str_id2=Source)
	 */
	protected void sequence_ConditionRanges_PartitionWithStream(ISerializationContext context, ConditionRanges semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstantValue returns ConstantValue
	 *
	 * Constraint:
	 *     (
	 *         bv=BoolValue | 
	 *         sdv=SignedDoubleValue | 
	 *         sfv=SignedFloatValue | 
	 *         slv=SignedLongValue | 
	 *         siv=SignedIntValue | 
	 *         tv=TimeValue | 
	 *         sv=StringValue
	 *     )
	 */
	protected void sequence_ConstantValue(ISerializationContext context, ConstantValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DayValue returns DayValue
	 *
	 * Constraint:
	 *     (day='day' | days='days')
	 */
	protected void sequence_DAYS(ISerializationContext context, DayValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AggregationTimeDuration returns AggregationTimeDuration
	 *
	 * Constraint:
	 *     (
	 *         year='year' | 
	 *         years='years' | 
	 *         month='month' | 
	 *         months='months' | 
	 *         week='week' | 
	 *         weeks='weeks' | 
	 *         day='day' | 
	 *         days='days' | 
	 *         hour='hour' | 
	 *         hours='hours' | 
	 *         minute='minute' | 
	 *         minutes='minutes' | 
	 *         min='min' | 
	 *         second='second' | 
	 *         seconds='seconds' | 
	 *         sec='sec'
	 *     )
	 */
	protected void sequence_DAYS_HOURS_MINUTES_MONTHS_SECONDS_WEEKS_YEARS(ISerializationContext context, AggregationTimeDuration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DefinitionFunction returns DefinitionFunction
	 *
	 * Constraint:
	 *     (
	 *         define='define' 
	 *         function='function' 
	 *         fn=FunctionName 
	 *         ln=LanguageName 
	 *         return='return' 
	 *         attr_type=AttributeType 
	 *         func_body=FunctionBody
	 *     )
	 */
	protected void sequence_DEFINE_DefinitionFunction_FUNCTION_RETURN(ISerializationContext context, DefinitionFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getDEFINE_Define()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getDEFINE_Define()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getFUNCTION_Function()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getFUNCTION_Function()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getDefinitionFunction_Fn()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getDefinitionFunction_Fn()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getDefinitionFunction_Ln()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getDefinitionFunction_Ln()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getRETURN_Return()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getRETURN_Return()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getDefinitionFunction_Attr_type()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getDefinitionFunction_Attr_type()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getDefinitionFunction_Func_body()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getDefinitionFunction_Func_body()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDEFINEAccess().getDefineDefineKeyword_0(), semanticObject.getDefine());
		feeder.accept(grammarAccess.getFUNCTIONAccess().getFunctionFunctionKeyword_0(), semanticObject.getFunction());
		feeder.accept(grammarAccess.getDefinitionFunctionAccess().getFnFunctionNameParserRuleCall_2_0(), semanticObject.getFn());
		feeder.accept(grammarAccess.getDefinitionFunctionAccess().getLnLanguageNameParserRuleCall_4_0(), semanticObject.getLn());
		feeder.accept(grammarAccess.getRETURNAccess().getReturnReturnKeyword_0(), semanticObject.getReturn());
		feeder.accept(grammarAccess.getDefinitionFunctionAccess().getAttr_typeAttributeTypeParserRuleCall_7_0(), semanticObject.getAttr_type());
		feeder.accept(grammarAccess.getDefinitionFunctionAccess().getFunc_bodyFunctionBodyParserRuleCall_8_0(), semanticObject.getFunc_body());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DefinitionStream returns DefinitionStream
	 *
	 * Constraint:
	 *     (
	 *         ann+=Annotation* 
	 *         define='define' 
	 *         (str='stream' | table='table') 
	 *         src=Source1 
	 *         feature+=Features 
	 *         feature+=Features*
	 *     )
	 */
	protected void sequence_DEFINE_DefinitionStream_STREAM_TABLE(ISerializationContext context, DefinitionStream semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DefinitionTable returns DefinitionTable
	 *
	 * Constraint:
	 *     (
	 *         ann1+=Annotation* 
	 *         define='define' 
	 *         table='table' 
	 *         src=Source1 
	 *         feature+=Features 
	 *         feature+=Features*
	 *     )
	 */
	protected void sequence_DEFINE_DefinitionTable_TABLE(ISerializationContext context, DefinitionTable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DefinitionWindow returns DefinitionWindow
	 *
	 * Constraint:
	 *     (
	 *         ann2+=Annotation* 
	 *         define='define' 
	 *         window='window' 
	 *         src=Source1 
	 *         feature+=Features 
	 *         feature+=Features* 
	 *         funcOp=FunctionOperation 
	 *         (output='output' opEventType=OutputEventType)?
	 *     )
	 */
	protected void sequence_DEFINE_DefinitionWindow_OUTPUT_WINDOW(ISerializationContext context, DefinitionWindow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     QueryOutput returns QueryOutput
	 *
	 * Constraint:
	 *     (
	 *         (return='return' outEventType=OutputEventType?) | 
	 *         (delete='delete' tar=Source1 (for='for' outEventType=OutputEventType)? on=ON expr=Expression) | 
	 *         (
	 *             ((delete='delete' tar=Source1 for='for' outEventType=OutputEventType) | (update='update' tar=Source1 (for='for' outEventType=OutputEventType)?)) 
	 *             setClause=SetClause? 
	 *             on=ON 
	 *             expr=Expression
	 *         ) | 
	 *         (
	 *             (update='update' or=OR)? 
	 *             insert='insert' 
	 *             outEventType=OutputEventType? 
	 *             into='into' 
	 *             (
	 *                 tar=Source1 | 
	 *                 (tar=Source1 for='for' outEventType=OutputEventType on=ON expr=Expression) | 
	 *                 (tar=Source1 (for='for' outEventType=OutputEventType)? setClause=SetClause? on=ON expr=Expression)
	 *             )
	 *         ) | 
	 *         (
	 *             update='update' 
	 *             tar=Source1 
	 *             for='for' 
	 *             outEventType=OutputEventType 
	 *             on=ON 
	 *             expr=Expression
	 *         )
	 *     )
	 */
	protected void sequence_DELETE_FOR_INSERT_INTO_QueryOutput_RETURN_UPDATE(ISerializationContext context, QueryOutput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SignedDoubleValue returns DOUBLE_LITERAL
	 *     DOUBLE_LITERAL returns DOUBLE_LITERAL
	 *
	 * Constraint:
	 *     ((e=E? d=D) | (e=E d=D?) | (e=E? d=D?))
	 */
	protected void sequence_DOUBLE_LITERAL(ISerializationContext context, DOUBLE_LITERAL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     D returns D
	 *
	 * Constraint:
	 *     d='d'
	 */
	protected void sequence_D(ISerializationContext context, D semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getD_D()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getD_D()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDAccess().getDDKeyword_0(), semanticObject.getD());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OutputRate returns OutputRate
	 *
	 * Constraint:
	 *     (
	 *         output='output' 
	 *         ((op_rate_type=OutputRateType? every=EVERY (tv=TimeValue | events='events')) | (snapshot='snapshot' every=EVERY tv=TimeValue))
	 *     )
	 */
	protected void sequence_EVENTS_OUTPUT_OutputRate_SNAPSHOT(ISerializationContext context, OutputRate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EVERY returns EVERY
	 *
	 * Constraint:
	 *     every='every'
	 */
	protected void sequence_EVERY(ISerializationContext context, EVERY semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getEVERY_Every()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getEVERY_Every()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEVERYAccess().getEveryEveryKeyword_0(), semanticObject.getEvery());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EveryAbsentPatternSource returns EVERY
	 *
	 * Constraint:
	 *     (every='every' basicAbsentPS=BasicAbsentPatternSource)
	 */
	protected void sequence_EVERY_EveryAbsentPatternSource(ISerializationContext context, EVERY semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getEVERY_Every()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getEVERY_Every()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getEveryAbsentPatternSource_BasicAbsentPS()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getEveryAbsentPatternSource_BasicAbsentPS()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEVERYAccess().getEveryEveryKeyword_0(), semanticObject.getEvery());
		feeder.accept(grammarAccess.getEveryAbsentPatternSourceAccess().getBasicAbsentPSBasicAbsentPatternSourceParserRuleCall_0_1_0(), semanticObject.getBasicAbsentPS());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EveryAbsentSequenceSourceChain returns EVERY
	 *
	 * Constraint:
	 *     (every='every' absSeqSrcChain=AbsentSequenceSourceChain seqSrcChain=SequenceSourceChain)
	 */
	protected void sequence_EVERY_EveryAbsentSequenceSourceChain(ISerializationContext context, EVERY semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getEVERY_Every()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getEVERY_Every()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getEveryAbsentSequenceSourceChain_AbsSeqSrcChain()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getEveryAbsentSequenceSourceChain_AbsSeqSrcChain()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getEveryAbsentSequenceSourceChain_SeqSrcChain()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getEveryAbsentSequenceSourceChain_SeqSrcChain()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEVERYAccess().getEveryEveryKeyword_0(), semanticObject.getEvery());
		feeder.accept(grammarAccess.getEveryAbsentSequenceSourceChainAccess().getAbsSeqSrcChainAbsentSequenceSourceChainParserRuleCall_0_1_0(), semanticObject.getAbsSeqSrcChain());
		feeder.accept(grammarAccess.getEveryAbsentSequenceSourceChainAccess().getSeqSrcChainSequenceSourceChainParserRuleCall_0_3_0(), semanticObject.getSeqSrcChain());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EverySequenceSourceChain returns EVERY
	 *
	 * Constraint:
	 *     (every='every' seqSource=SequenceSource wt=WithinTime? ssc=SequenceSourceChain)
	 */
	protected void sequence_EVERY_EverySequenceSourceChain(ISerializationContext context, EVERY semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LeftAbsentPatternSource returns EVERY
	 *     LeftAbsentPatternSource.LeftAbsentPatternSource_1_0_0 returns EVERY
	 *     LeftAbsentPatternSource1 returns EVERY
	 *     LeftAbsentPatternSource1.LeftAbsentPatternSource1_1_0_0 returns EVERY
	 *     LeftAbsentPatternSource2 returns EVERY
	 *
	 * Constraint:
	 *     (every='every' leftAbsPS=LeftAbsentPatternSource wt2+=WithinTime?)
	 */
	protected void sequence_EVERY_LeftAbsentPatternSource2(ISerializationContext context, EVERY semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RightAbsentPatternSource returns EVERY
	 *     RightAbsentPatternSource.RightAbsentPatternSource_1_0_0 returns EVERY
	 *     RightAbsentPatternSource1 returns EVERY
	 *     RightAbsentPatternSource1.RightAbsentPatternSource1_1_0_0 returns EVERY
	 *     RightAbsentPatternSource2 returns EVERY
	 *
	 * Constraint:
	 *     (every='every' rightAbsPS=RightAbsentPatternSource wt3+=WithinTime?)
	 */
	protected void sequence_EVERY_RightAbsentPatternSource2(ISerializationContext context, EVERY semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     E returns E
	 *
	 * Constraint:
	 *     e='e'
	 */
	protected void sequence_E(ISerializationContext context, E semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getE_E()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getE_E()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEAccess().getEEKeyword_0(), semanticObject.getE());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PatternStream returns EveryAbsentPatternSource
	 *     AbsentPatternSourceChain returns EveryAbsentPatternSource
	 *     EveryAbsentPatternSource returns EveryAbsentPatternSource
	 *
	 * Constraint:
	 *     basicAbsentPS=BasicAbsentPatternSource
	 */
	protected void sequence_EveryAbsentPatternSource(ISerializationContext context, EveryAbsentPatternSource semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getEveryAbsentPatternSource_BasicAbsentPS()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getEveryAbsentPatternSource_BasicAbsentPS()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEveryAbsentPatternSourceAccess().getBasicAbsentPSBasicAbsentPatternSourceParserRuleCall_0_1_0(), semanticObject.getBasicAbsentPS());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EveryAbsentSequenceSourceChain returns EveryAbsentSequenceSourceChain
	 *
	 * Constraint:
	 *     (absSeqSrcChain=AbsentSequenceSourceChain seqSrcChain=SequenceSourceChain)
	 */
	protected void sequence_EveryAbsentSequenceSourceChain(ISerializationContext context, EveryAbsentSequenceSourceChain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getEveryAbsentSequenceSourceChain_AbsSeqSrcChain()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getEveryAbsentSequenceSourceChain_AbsSeqSrcChain()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getEveryAbsentSequenceSourceChain_SeqSrcChain()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getEveryAbsentSequenceSourceChain_SeqSrcChain()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEveryAbsentSequenceSourceChainAccess().getAbsSeqSrcChainAbsentSequenceSourceChainParserRuleCall_0_1_0(), semanticObject.getAbsSeqSrcChain());
		feeder.accept(grammarAccess.getEveryAbsentSequenceSourceChainAccess().getSeqSrcChainSequenceSourceChainParserRuleCall_0_3_0(), semanticObject.getSeqSrcChain());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EveryPatternSourceChain1 returns EveryPatternSourceChain
	 *
	 * Constraint:
	 *     ((eps=EveryPatternSourceChain wt=WithinTime?) | psc=PatternSourceChain | (every=EVERY psc=PatternSourceChain1))
	 */
	protected void sequence_EveryPatternSourceChain1(ISerializationContext context, EveryPatternSourceChain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternStream returns EveryPatternSourceChain
	 *     EveryPatternSourceChain returns EveryPatternSourceChain
	 *     EveryPatternSourceChain.EveryPatternSourceChain_1_0_0 returns EveryPatternSourceChain
	 *
	 * Constraint:
	 *     (
	 *         (left=EveryPatternSourceChain_EveryPatternSourceChain_1_0_0 op='->' right=EveryPatternSourceChain1) | 
	 *         (eps=EveryPatternSourceChain wt=WithinTime?) | 
	 *         psc=PatternSourceChain | 
	 *         (every=EVERY psc=PatternSourceChain1)
	 *     )
	 */
	protected void sequence_EveryPatternSourceChain_EveryPatternSourceChain1(ISerializationContext context, EveryPatternSourceChain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EverySequenceSourceChain returns EverySequenceSourceChain
	 *
	 * Constraint:
	 *     (seqSource=SequenceSource wt=WithinTime? ssc=SequenceSourceChain)
	 */
	protected void sequence_EverySequenceSourceChain(ISerializationContext context, EverySequenceSourceChain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExecutionElement returns ExecutionElement
	 *
	 * Constraint:
	 *     (execPartition=ExecPartition | que=Query)
	 */
	protected void sequence_ExecutionElement(ISerializationContext context, ExecutionElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExecutionPlan returns ExecutionPlan
	 *
	 * Constraint:
	 *     (
	 *         appAnn+=AppAnnotation* 
	 *         (
	 *             defStream+=DefinitionStream | 
	 *             defTable+=DefinitionTable | 
	 *             def_window+=DefinitionWindow | 
	 *             defTrigger+=DefinitionTrigger | 
	 *             defFunction+=DefinitionFunction | 
	 *             defAgrregation+=DefinitionAggregation
	 *         ) 
	 *         defStream+=DefinitionStream? 
	 *         (
	 *             (
	 *                 defTable+=DefinitionTable | 
	 *                 def_window+=DefinitionWindow | 
	 *                 defTrigger+=DefinitionTrigger | 
	 *                 defFunction+=DefinitionFunction | 
	 *                 defAgrregation+=DefinitionAggregation
	 *             )? 
	 *             defStream+=DefinitionStream?
	 *         )* 
	 *         exElement+=ExecutionElement*
	 *     )
	 */
	protected void sequence_ExecutionPlan(ISerializationContext context, ExecutionPlan semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BoolValue returns BoolValue
	 *
	 * Constraint:
	 *     (fals='false' | tr='true')
	 */
	protected void sequence_FALSE_TRUE(ISerializationContext context, BoolValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SignedFloatValue returns FLOAT_LITERAL
	 *     FLOAT_LITERAL returns FLOAT_LITERAL
	 *
	 * Constraint:
	 *     ((e=E? f=F) | (e=E? f=F))
	 */
	protected void sequence_FLOAT_LITERAL(ISerializationContext context, FLOAT_LITERAL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForTime returns ForTime
	 *
	 * Constraint:
	 *     (for='for' tv=TimeValue)
	 */
	protected void sequence_FOR_ForTime(ISerializationContext context, ForTime semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getFOR_For()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getFOR_For()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getForTime_Tv()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getForTime_Tv()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFORAccess().getForForKeyword_0(), semanticObject.getFor());
		feeder.accept(grammarAccess.getForTimeAccess().getTvTimeValueParserRuleCall_1_0(), semanticObject.getTv());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Query returns Query
	 *
	 * Constraint:
	 *     (
	 *         ann3+=Annotation* 
	 *         from='from' 
	 *         qInp=QueryInput 
	 *         querySec=QuerySection? 
	 *         outRate=OutputRate? 
	 *         qOutput=QueryOutput?
	 *     )
	 */
	protected void sequence_FROM_Query(ISerializationContext context, Query semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     joins returns joins
	 *
	 * Constraint:
	 *     ((((left='left' | right='right' | full='full')? outer='outer') | inner='inner')? join='join')
	 */
	protected void sequence_FULL_INNER_JOIN_LEFT_OUTER_RIGHT_joins(ISerializationContext context, joins semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     F returns F
	 *
	 * Constraint:
	 *     f='f'
	 */
	protected void sequence_F(ISerializationContext context, F semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getF_F()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getF_F()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFAccess().getFFKeyword_0(), semanticObject.getF());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FeaturesOrOutAttrReference returns FeaturesOrOutAttrReference
	 *
	 * Constraint:
	 *     srcoutAttrref=[FeaturesOrOutAttr|IdNew]
	 */
	protected void sequence_FeaturesOrOutAttrReference(ISerializationContext context, FeaturesOrOutAttrReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getFeaturesOrOutAttrReference_SrcoutAttrref()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getFeaturesOrOutAttrReference_SrcoutAttrref()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFeaturesOrOutAttrReferenceAccess().getSrcoutAttrrefFeaturesOrOutAttrIdNewParserRuleCall_0_1(), semanticObject.eGet(SiddhiPackage.eINSTANCE.getFeaturesOrOutAttrReference_SrcoutAttrref(), false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Features returns Features
	 *     FeaturesOrOutAttr returns Features
	 *
	 * Constraint:
	 *     (name=IdNew type=AttributeType)
	 */
	protected void sequence_Features(ISerializationContext context, Features semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getFeaturesOrOutAttr_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getFeaturesOrOutAttr_Name()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getFeatures_Type()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getFeatures_Type()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFeaturesAccess().getNameIdNewParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFeaturesAccess().getTypeAttributeTypeParserRuleCall_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns Filter
	 *
	 * Constraint:
	 *     exp=Expression
	 */
	protected void sequence_Filter(ISerializationContext context, Filter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getFilter_Exp()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getFilter_Exp()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFilterAccess().getExpExpressionParserRuleCall_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionBody returns FunctionBody
	 *
	 * Constraint:
	 *     value=SCRIPT
	 */
	protected void sequence_FunctionBody(ISerializationContext context, FunctionBody semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getFunctionBody_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getFunctionBody_Value()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionBodyAccess().getValueSCRIPTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionId returns FunctionId
	 *
	 * Constraint:
	 *     na=Name
	 */
	protected void sequence_FunctionId(ISerializationContext context, FunctionId semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getFunctionId_Na()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getFunctionId_Na()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionIdAccess().getNaNameParserRuleCall_0(), semanticObject.getNa());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionName returns FunctionName
	 *
	 * Constraint:
	 *     id=ID
	 */
	protected void sequence_FunctionName(ISerializationContext context, FunctionName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getFunctionName_Id()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getFunctionName_Id()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionNameAccess().getIdIDTerminalRuleCall_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionNamespace returns FunctionNamespace
	 *
	 * Constraint:
	 *     na=IdNew
	 */
	protected void sequence_FunctionNamespace(ISerializationContext context, FunctionNamespace semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getFunctionNamespace_Na()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getFunctionNamespace_Na()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionNamespaceAccess().getNaIdNewParserRuleCall_0(), semanticObject.getNa());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionOperation returns FunctionOperation
	 *
	 * Constraint:
	 *     (funcNamespace=FunctionNamespace? funcId=FunctionId attrList=AttributeList?)
	 */
	protected void sequence_FunctionOperation(ISerializationContext context, FunctionOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GroupByQuerySelection returns GroupByQuerySelection
	 *
	 * Constraint:
	 *     (select='select' (out_att+=OutputAttribute out_att+=OutputAttribute*)? grp_by=GroupBy?)
	 */
	protected void sequence_GroupByQuerySelection_SELECT(ISerializationContext context, GroupByQuerySelection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HavingExpr returns HavingExpr
	 *
	 * Constraint:
	 *     (having='having' expr=Expression)
	 */
	protected void sequence_HAVING_HavingExpr(ISerializationContext context, HavingExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getHAVING_Having()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getHAVING_Having()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getHavingExpr_Expr()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getHavingExpr_Expr()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHAVINGAccess().getHavingHavingKeyword_0(), semanticObject.getHaving());
		feeder.accept(grammarAccess.getHavingExprAccess().getExprExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     HourValue returns HourValue
	 *
	 * Constraint:
	 *     (hour='hour' | hours='hours')
	 */
	protected void sequence_HOURS(ISerializationContext context, HourValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IN returns IN
	 *
	 * Constraint:
	 *     in='in'
	 */
	protected void sequence_IN(ISerializationContext context, IN semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getIN_In()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getIN_In()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getINAccess().getInInKeyword_0(), semanticObject.getIn());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MathLogicalOperation returns NullCheck
	 *     MathLogicalOperation.MathLogicalOperation_1_0_0 returns NullCheck
	 *     MathInOperation returns NullCheck
	 *     MathInOperation.MathInOperation_1_0_0 returns NullCheck
	 *     MathGtLtOperation returns NullCheck
	 *     MathGtLtOperation.MathGtLtOperation_1_0_0 returns NullCheck
	 *     MathEqualOperation returns NullCheck
	 *     MathEqualOperation.MathEqualOperation_1_0_0 returns NullCheck
	 *     MathAddsubOperation returns NullCheck
	 *     MathAddsubOperation.MathAddsubOperation_1_0_0 returns NullCheck
	 *     MathDivmulOperation returns NullCheck
	 *     MathDivmulOperation.MathDivmulOperation_1_0_0 returns NullCheck
	 *     MathOtherOperations returns NullCheck
	 *     NullCheck returns NullCheck
	 *
	 * Constraint:
	 *     ((stream_ref=StreamReference | attr_ref=AttributeReference | fo=FunctionOperation) is='is' null='null')
	 */
	protected void sequence_IS_NULL_NullCheck(ISerializationContext context, NullCheck semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JoinSource returns MainSource
	 *
	 * Constraint:
	 *     (src=Source basicSSh=BasicSourceStreamHandlers1 (a=AS strAlias=StreamAlias)?)
	 */
	protected void sequence_JoinSource_MainSource(ISerializationContext context, MainSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JoinStream returns JoinStream
	 *
	 * Constraint:
	 *     (
	 *         (left_source=JoinSource right_source=JoinSource right_uni=UNIDIRECTIONAL (on=ON expr=Expression)? wt=WithinTime?) | 
	 *         (left_source=JoinSource join=joins right_source=JoinSource (on=ON expr=Expression)? wt=WithinTime?) | 
	 *         (
	 *             left_source=JoinSource 
	 *             left_uni=UNIDIRECTIONAL 
	 *             join=joins 
	 *             right_source=JoinSource 
	 *             (on=ON expr=Expression)? 
	 *             wt=WithinTime?
	 *         )
	 *     )
	 */
	protected void sequence_JoinStream(ISerializationContext context, JoinStream semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SignedLongValue returns LONG_LITERAL
	 *     LONG_LITERAL returns LONG_LITERAL
	 *
	 * Constraint:
	 *     l=L
	 */
	protected void sequence_LONG_LITERAL(ISerializationContext context, LONG_LITERAL semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getLONG_LITERAL_L()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getLONG_LITERAL_L()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLONG_LITERALAccess().getLLParserRuleCall_1_0(), semanticObject.getL());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     L returns L
	 *
	 * Constraint:
	 *     l='l'
	 */
	protected void sequence_L(ISerializationContext context, L semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getL_L()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getL_L()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLAccess().getLLKeyword_0(), semanticObject.getL());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LanguageName returns LanguageName
	 *
	 * Constraint:
	 *     id=ID
	 */
	protected void sequence_LanguageName(ISerializationContext context, LanguageName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getLanguageName_Id()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getLanguageName_Id()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLanguageNameAccess().getIdIDTerminalRuleCall_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PatternStream returns LeftAbsentPatternSource1
	 *     AbsentPatternSourceChain returns LeftAbsentPatternSource1
	 *     LeftAbsentPatternSource returns LeftAbsentPatternSource1
	 *     LeftAbsentPatternSource.LeftAbsentPatternSource_1_0_0 returns LeftAbsentPatternSource1
	 *     LeftAbsentPatternSource1 returns LeftAbsentPatternSource1
	 *     LeftAbsentPatternSource1.LeftAbsentPatternSource1_1_0_0 returns LeftAbsentPatternSource1
	 *
	 * Constraint:
	 *     (left=LeftAbsentPatternSource1_LeftAbsentPatternSource1_1_0_0 fb='->' right=EveryAbsentPatternSource)
	 */
	protected void sequence_LeftAbsentPatternSource1(ISerializationContext context, LeftAbsentPatternSource1 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getLeftAbsentPatternSource_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getLeftAbsentPatternSource_Left()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getLeftAbsentPatternSource1_Fb()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getLeftAbsentPatternSource1_Fb()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getLeftAbsentPatternSource_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getLeftAbsentPatternSource_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLeftAbsentPatternSource1Access().getLeftAbsentPatternSource1LeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLeftAbsentPatternSource1Access().getFbHyphenMinusGreaterThanSignKeyword_1_0_1_0(), semanticObject.getFb());
		feeder.accept(grammarAccess.getLeftAbsentPatternSource1Access().getRightEveryAbsentPatternSourceParserRuleCall_1_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LeftAbsentPatternSource1 returns LeftAbsentPatternSource
	 *     LeftAbsentPatternSource1.LeftAbsentPatternSource1_1_0_0 returns LeftAbsentPatternSource
	 *     LeftAbsentPatternSource2 returns LeftAbsentPatternSource
	 *
	 * Constraint:
	 *     (
	 *         (leftAbsPS=LeftAbsentPatternSource wt2+=WithinTime?) | 
	 *         (everyAbsPS=EveryAbsentPatternSource everyPSC=EveryPatternSourceChain) | 
	 *         (everyPSC=EveryPatternSourceChain leftAbsPatternSrc=LeftAbsentPatternSource)
	 *     )
	 */
	protected void sequence_LeftAbsentPatternSource2(ISerializationContext context, LeftAbsentPatternSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternStream returns LeftAbsentPatternSource
	 *     AbsentPatternSourceChain returns LeftAbsentPatternSource
	 *     LeftAbsentPatternSource returns LeftAbsentPatternSource
	 *     LeftAbsentPatternSource.LeftAbsentPatternSource_1_0_0 returns LeftAbsentPatternSource
	 *
	 * Constraint:
	 *     (
	 *         (left=LeftAbsentPatternSource_LeftAbsentPatternSource_1_0_0 fb1='->' right=LeftAbsentPatternSource1) | 
	 *         (leftAbsPS=LeftAbsentPatternSource wt2+=WithinTime?) | 
	 *         (everyAbsPS=EveryAbsentPatternSource everyPSC=EveryPatternSourceChain) | 
	 *         (everyPSC=EveryPatternSourceChain leftAbsPatternSrc=LeftAbsentPatternSource)
	 *     )
	 */
	protected void sequence_LeftAbsentPatternSource_LeftAbsentPatternSource2(ISerializationContext context, LeftAbsentPatternSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LeftAbsentSequenceSource returns LeftAbsentSequenceSource1
	 *     LeftAbsentSequenceSource.LeftAbsentSequenceSource_1_0_0 returns LeftAbsentSequenceSource1
	 *     LeftAbsentSequenceSource1 returns LeftAbsentSequenceSource1
	 *     LeftAbsentSequenceSource1.LeftAbsentSequenceSource1_1_0_0 returns LeftAbsentSequenceSource1
	 *
	 * Constraint:
	 *     (left=LeftAbsentSequenceSource1_LeftAbsentSequenceSource1_1_0_0 comm=',' right=BasicAbsentPatternSource)
	 */
	protected void sequence_LeftAbsentSequenceSource1(ISerializationContext context, LeftAbsentSequenceSource1 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getLeftAbsentSequenceSource_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getLeftAbsentSequenceSource_Left()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getLeftAbsentSequenceSource_Comm()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getLeftAbsentSequenceSource_Comm()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getLeftAbsentSequenceSource_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getLeftAbsentSequenceSource_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLeftAbsentSequenceSource1Access().getLeftAbsentSequenceSource1LeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLeftAbsentSequenceSource1Access().getCommCommaKeyword_1_0_1_0(), semanticObject.getComm());
		feeder.accept(grammarAccess.getLeftAbsentSequenceSource1Access().getRightBasicAbsentPatternSourceParserRuleCall_1_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LeftAbsentSequenceSource1 returns LeftAbsentSequenceSource
	 *     LeftAbsentSequenceSource1.LeftAbsentSequenceSource1_1_0_0 returns LeftAbsentSequenceSource
	 *     LeftAbsentSequenceSource2 returns LeftAbsentSequenceSource
	 *
	 * Constraint:
	 *     (
	 *         (op=OPEN_PAR leftAbsentSequenceSource=LeftAbsentSequenceSource cp=CLOSE_PAR wt6=WithinTime?) | 
	 *         (basicAbsentPatternSource=BasicAbsentPatternSource comma=',' sequenceSourceChain=SequenceSourceChain) | 
	 *         (sequenceSourceChain=SequenceSourceChain comma=',' leftAbsentSequenceSource=LeftAbsentSequenceSource)
	 *     )
	 */
	protected void sequence_LeftAbsentSequenceSource2(ISerializationContext context, LeftAbsentSequenceSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LeftAbsentSequenceSource returns LeftAbsentSequenceSource
	 *     LeftAbsentSequenceSource.LeftAbsentSequenceSource_1_0_0 returns LeftAbsentSequenceSource
	 *
	 * Constraint:
	 *     (
	 *         (left=LeftAbsentSequenceSource_LeftAbsentSequenceSource_1_0_0 comm=',' right=LeftAbsentSequenceSource1) | 
	 *         (op=OPEN_PAR leftAbsentSequenceSource=LeftAbsentSequenceSource cp=CLOSE_PAR wt6=WithinTime?) | 
	 *         (basicAbsentPatternSource=BasicAbsentPatternSource comma=',' sequenceSourceChain=SequenceSourceChain) | 
	 *         (sequenceSourceChain=SequenceSourceChain comma=',' leftAbsentSequenceSource=LeftAbsentSequenceSource)
	 *     )
	 */
	protected void sequence_LeftAbsentSequenceSource_LeftAbsentSequenceSource2(ISerializationContext context, LeftAbsentSequenceSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalAbsentStatefulSource returns LogicalAbsentStatefulSource
	 *     SequenceSource returns LogicalAbsentStatefulSource
	 *
	 * Constraint:
	 *     (
	 *         logicalAbsStatefulSrc=LogicalAbsentStatefulSource | 
	 *         (stdSource=StandardStatefulSource and=AND not=NOT bs=BasicSource) | 
	 *         (stdSource=StandardStatefulSource and=AND basicAbsentPatternSource1=BasicAbsentPatternSource) | 
	 *         (basicAbsentPatternSource1=BasicAbsentPatternSource and=AND stdSource=StandardStatefulSource) | 
	 *         (basicAbsentPatternSource2=BasicAbsentPatternSource and=AND basicAbsentPatternSource=BasicAbsentPatternSource) | 
	 *         (stdSource=StandardStatefulSource o=OR basicAbsentPatternSource1=BasicAbsentPatternSource) | 
	 *         (basicAbsentPatternSource1=BasicAbsentPatternSource o=OR stdSource=StandardStatefulSource) | 
	 *         (basicAbsentPatternSource2=BasicAbsentPatternSource o=OR basicAbsentPatternSource=BasicAbsentPatternSource)
	 *     )
	 */
	protected void sequence_LogicalAbsentStatefulSource(ISerializationContext context, LogicalAbsentStatefulSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalAbsentStatefulSource returns NOT
	 *     SequenceSource returns NOT
	 *
	 * Constraint:
	 *     (not1='not' bs=BasicSource and=AND stdSource=StandardStatefulSource)
	 */
	protected void sequence_LogicalAbsentStatefulSource_NOT(ISerializationContext context, NOT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getNOT_Not1()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getNOT_Not1()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getLogicalAbsentStatefulSource_Bs()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getLogicalAbsentStatefulSource_Bs()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getLogicalAbsentStatefulSource_And()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getLogicalAbsentStatefulSource_And()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getLogicalAbsentStatefulSource_StdSource()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getLogicalAbsentStatefulSource_StdSource()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNOTAccess().getNot1NotKeyword_0(), semanticObject.getNot1());
		feeder.accept(grammarAccess.getLogicalAbsentStatefulSourceAccess().getBsBasicSourceParserRuleCall_2_0_0_1_0(), semanticObject.getBs());
		feeder.accept(grammarAccess.getLogicalAbsentStatefulSourceAccess().getAndANDParserRuleCall_2_0_0_2_0(), semanticObject.getAnd());
		feeder.accept(grammarAccess.getLogicalAbsentStatefulSourceAccess().getStdSourceStandardStatefulSourceParserRuleCall_2_1_0(), semanticObject.getStdSource());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SequenceSourceChain returns NOT
	 *     SequenceSourceChain.SequenceSourceChain_1_0_0 returns NOT
	 *     SequenceSourceChain1 returns NOT
	 *
	 * Constraint:
	 *     (
	 *         not1='not' 
	 *         bs=BasicSource 
	 *         and=AND 
	 *         stdSource=StandardStatefulSource 
	 *         wt=WithinTime? 
	 *         wt1+=WithinTime*
	 *     )
	 */
	protected void sequence_LogicalAbsentStatefulSource_NOT_SequenceSourceChain1(ISerializationContext context, NOT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SequenceSourceChain returns LogicalAbsentStatefulSource
	 *     SequenceSourceChain.SequenceSourceChain_1_0_0 returns LogicalAbsentStatefulSource
	 *     SequenceSourceChain1 returns LogicalAbsentStatefulSource
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             logicalAbsStatefulSrc=LogicalAbsentStatefulSource | 
	 *             (stdSource=StandardStatefulSource and=AND not=NOT bs=BasicSource) | 
	 *             (stdSource=StandardStatefulSource and=AND basicAbsentPatternSource1=BasicAbsentPatternSource) | 
	 *             (basicAbsentPatternSource1=BasicAbsentPatternSource and=AND stdSource=StandardStatefulSource) | 
	 *             (basicAbsentPatternSource2=BasicAbsentPatternSource and=AND basicAbsentPatternSource=BasicAbsentPatternSource) | 
	 *             (stdSource=StandardStatefulSource o=OR basicAbsentPatternSource1=BasicAbsentPatternSource) | 
	 *             (basicAbsentPatternSource1=BasicAbsentPatternSource o=OR stdSource=StandardStatefulSource) | 
	 *             (basicAbsentPatternSource2=BasicAbsentPatternSource o=OR basicAbsentPatternSource=BasicAbsentPatternSource)
	 *         ) 
	 *         wt=WithinTime? 
	 *         wt1+=WithinTime*
	 *     )
	 */
	protected void sequence_LogicalAbsentStatefulSource_SequenceSourceChain1(ISerializationContext context, LogicalAbsentStatefulSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalStatefulSource returns LogicalStatefulSource
	 *     SequenceSource returns LogicalStatefulSource
	 *
	 * Constraint:
	 *     (
	 *         (stdSource+=StandardStatefulSource and=AND stdSource+=StandardStatefulSource) | 
	 *         (stdSource+=StandardStatefulSource or=OR stdSource+=StandardStatefulSource)
	 *     )
	 */
	protected void sequence_LogicalStatefulSource(ISerializationContext context, LogicalStatefulSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SequenceSourceChain returns LogicalStatefulSource
	 *     SequenceSourceChain.SequenceSourceChain_1_0_0 returns LogicalStatefulSource
	 *     SequenceSourceChain1 returns LogicalStatefulSource
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (stdSource+=StandardStatefulSource and=AND stdSource+=StandardStatefulSource) | 
	 *             (stdSource+=StandardStatefulSource or=OR stdSource+=StandardStatefulSource)
	 *         ) 
	 *         wt=WithinTime? 
	 *         wt1+=WithinTime*
	 *     )
	 */
	protected void sequence_LogicalStatefulSource_SequenceSourceChain1(ISerializationContext context, LogicalStatefulSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MillisecondValue returns MillisecondValue
	 *
	 * Constraint:
	 *     (millisecond='millisecond' | milliseconds='milliseconds' | millisec='millisec')
	 */
	protected void sequence_MILLISECONDS(ISerializationContext context, MillisecondValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MinuteValue returns MinuteValue
	 *
	 * Constraint:
	 *     (minute='minute' | minutes='minutes' | min='min')
	 */
	protected void sequence_MINUTES(ISerializationContext context, MinuteValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MonthValue returns MonthValue
	 *
	 * Constraint:
	 *     (month='month' | months='months')
	 */
	protected void sequence_MONTHS(ISerializationContext context, MonthValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MainSource returns MainSource
	 *
	 * Constraint:
	 *     (src=Source basicSSh=BasicSourceStreamHandlers1)
	 */
	protected void sequence_MainSource(ISerializationContext context, MainSource semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getMainSource_Src()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getMainSource_Src()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getMainSource_BasicSSh()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getMainSource_BasicSSh()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMainSourceAccess().getSrcSourceParserRuleCall_0_0(), semanticObject.getSrc());
		feeder.accept(grammarAccess.getMainSourceAccess().getBasicSShBasicSourceStreamHandlers1ParserRuleCall_1_0(), semanticObject.getBasicSSh());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     JoinStream returns MainSource
	 *     StandardStream returns MainSource
	 *
	 * Constraint:
	 *     (src=Source basicSSh=BasicSourceStreamHandlers1 postWindowHandlers=BasicSourceStreamHandlers?)
	 */
	protected void sequence_MainSource_StandardStream(ISerializationContext context, MainSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MathLogicalOperation returns MathAddsubOperation
	 *     MathLogicalOperation.MathLogicalOperation_1_0_0 returns MathAddsubOperation
	 *     MathInOperation returns MathAddsubOperation
	 *     MathInOperation.MathInOperation_1_0_0 returns MathAddsubOperation
	 *     MathGtLtOperation returns MathAddsubOperation
	 *     MathGtLtOperation.MathGtLtOperation_1_0_0 returns MathAddsubOperation
	 *     MathEqualOperation returns MathAddsubOperation
	 *     MathEqualOperation.MathEqualOperation_1_0_0 returns MathAddsubOperation
	 *     MathAddsubOperation returns MathAddsubOperation
	 *     MathAddsubOperation.MathAddsubOperation_1_0_0 returns MathAddsubOperation
	 *
	 * Constraint:
	 *     (left=MathAddsubOperation_MathAddsubOperation_1_0_0 (add='+' | substract='-') right=MathDivmulOperation)
	 */
	protected void sequence_MathAddsubOperation(ISerializationContext context, MathAddsubOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MathLogicalOperation returns MathDivmulOperation
	 *     MathLogicalOperation.MathLogicalOperation_1_0_0 returns MathDivmulOperation
	 *     MathInOperation returns MathDivmulOperation
	 *     MathInOperation.MathInOperation_1_0_0 returns MathDivmulOperation
	 *     MathGtLtOperation returns MathDivmulOperation
	 *     MathGtLtOperation.MathGtLtOperation_1_0_0 returns MathDivmulOperation
	 *     MathEqualOperation returns MathDivmulOperation
	 *     MathEqualOperation.MathEqualOperation_1_0_0 returns MathDivmulOperation
	 *     MathAddsubOperation returns MathDivmulOperation
	 *     MathAddsubOperation.MathAddsubOperation_1_0_0 returns MathDivmulOperation
	 *     MathDivmulOperation returns MathDivmulOperation
	 *     MathDivmulOperation.MathDivmulOperation_1_0_0 returns MathDivmulOperation
	 *
	 * Constraint:
	 *     (left=MathDivmulOperation_MathDivmulOperation_1_0_0 (multiply='*' | devide='/' | mod='%') right=MathOtherOperations)
	 */
	protected void sequence_MathDivmulOperation(ISerializationContext context, MathDivmulOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MathLogicalOperation returns MathEqualOperation
	 *     MathLogicalOperation.MathLogicalOperation_1_0_0 returns MathEqualOperation
	 *     MathInOperation returns MathEqualOperation
	 *     MathInOperation.MathInOperation_1_0_0 returns MathEqualOperation
	 *     MathGtLtOperation returns MathEqualOperation
	 *     MathGtLtOperation.MathGtLtOperation_1_0_0 returns MathEqualOperation
	 *     MathEqualOperation returns MathEqualOperation
	 *     MathEqualOperation.MathEqualOperation_1_0_0 returns MathEqualOperation
	 *
	 * Constraint:
	 *     (left=MathEqualOperation_MathEqualOperation_1_0_0 (eq='==' | not_eq='!=') right=MathAddsubOperation)
	 */
	protected void sequence_MathEqualOperation(ISerializationContext context, MathEqualOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MathLogicalOperation returns MathGtLtOperation
	 *     MathLogicalOperation.MathLogicalOperation_1_0_0 returns MathGtLtOperation
	 *     MathInOperation returns MathGtLtOperation
	 *     MathInOperation.MathInOperation_1_0_0 returns MathGtLtOperation
	 *     MathGtLtOperation returns MathGtLtOperation
	 *     MathGtLtOperation.MathGtLtOperation_1_0_0 returns MathGtLtOperation
	 *
	 * Constraint:
	 *     (left=MathGtLtOperation_MathGtLtOperation_1_0_0 (symbol='>=' | symbol='<=' | symbol='>' | symbol='<') right=MathGtLtOperation)
	 */
	protected void sequence_MathGtLtOperation(ISerializationContext context, MathGtLtOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MathLogicalOperation returns MathInOperation
	 *     MathLogicalOperation.MathLogicalOperation_1_0_0 returns MathInOperation
	 *     MathInOperation returns MathInOperation
	 *     MathInOperation.MathInOperation_1_0_0 returns MathInOperation
	 *
	 * Constraint:
	 *     (left=MathInOperation_MathInOperation_1_0_0 in=IN right=Name)
	 */
	protected void sequence_MathInOperation(ISerializationContext context, MathInOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getMathInOperation_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getMathInOperation_Left()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getMathInOperation_In()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getMathInOperation_In()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getMathInOperation_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getMathInOperation_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMathInOperationAccess().getMathInOperationLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMathInOperationAccess().getInINParserRuleCall_1_0_1_0(), semanticObject.getIn());
		feeder.accept(grammarAccess.getMathInOperationAccess().getRightNameParserRuleCall_1_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MathLogicalOperation returns MathLogicalOperation
	 *     MathLogicalOperation.MathLogicalOperation_1_0_0 returns MathLogicalOperation
	 *
	 * Constraint:
	 *     (left=MathLogicalOperation_MathLogicalOperation_1_0_0 (and=AND | or=OR) right=MathInOperation)
	 */
	protected void sequence_MathLogicalOperation(ISerializationContext context, MathLogicalOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MathOperation
	 *     MathOperation returns MathOperation
	 *
	 * Constraint:
	 *     mlo=MathLogicalOperation
	 */
	protected void sequence_MathOperation(ISerializationContext context, MathOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getMathOperation_Mlo()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getMathOperation_Mlo()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMathOperationAccess().getMloMathLogicalOperationParserRuleCall_0(), semanticObject.getMlo());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MathOtherOperations1 returns MathOtherOperations1
	 *
	 * Constraint:
	 *     (const_val=ConstantValue | fo=FunctionOperation | attrRef=AttributeReference)
	 */
	protected void sequence_MathOtherOperations1(ISerializationContext context, MathOtherOperations1 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MathLogicalOperation returns MathOperation
	 *     MathLogicalOperation.MathLogicalOperation_1_0_0 returns MathOperation
	 *     MathInOperation returns MathOperation
	 *     MathInOperation.MathInOperation_1_0_0 returns MathOperation
	 *     MathGtLtOperation returns MathOperation
	 *     MathGtLtOperation.MathGtLtOperation_1_0_0 returns MathOperation
	 *     MathEqualOperation returns MathOperation
	 *     MathEqualOperation.MathEqualOperation_1_0_0 returns MathOperation
	 *     MathAddsubOperation returns MathOperation
	 *     MathAddsubOperation.MathAddsubOperation_1_0_0 returns MathOperation
	 *     MathDivmulOperation returns MathOperation
	 *     MathDivmulOperation.MathDivmulOperation_1_0_0 returns MathOperation
	 *     MathOtherOperations returns MathOperation
	 *
	 * Constraint:
	 *     (op=MathOperation | mathOtherOperations1=MathOtherOperations1)
	 */
	protected void sequence_MathOtherOperations(ISerializationContext context, MathOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MathLogicalOperation returns NotOperation
	 *     MathLogicalOperation.MathLogicalOperation_1_0_0 returns NotOperation
	 *     MathInOperation returns NotOperation
	 *     MathInOperation.MathInOperation_1_0_0 returns NotOperation
	 *     MathGtLtOperation returns NotOperation
	 *     MathGtLtOperation.MathGtLtOperation_1_0_0 returns NotOperation
	 *     MathEqualOperation returns NotOperation
	 *     MathEqualOperation.MathEqualOperation_1_0_0 returns NotOperation
	 *     MathAddsubOperation returns NotOperation
	 *     MathAddsubOperation.MathAddsubOperation_1_0_0 returns NotOperation
	 *     MathDivmulOperation returns NotOperation
	 *     MathDivmulOperation.MathDivmulOperation_1_0_0 returns NotOperation
	 *     MathOtherOperations returns NotOperation
	 *
	 * Constraint:
	 *     (not=NOT op=MathOperation)
	 */
	protected void sequence_MathOtherOperations(ISerializationContext context, NotOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getNotOperation_Not()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getNotOperation_Not()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getMathOperation_Op()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getMathOperation_Op()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMathOtherOperationsAccess().getNotNOTParserRuleCall_0_0_1_0(), semanticObject.getNot());
		feeder.accept(grammarAccess.getMathOtherOperationsAccess().getOpMathOperationParserRuleCall_0_0_2_0(), semanticObject.getOp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NOT returns NOT
	 *
	 * Constraint:
	 *     not1='not'
	 */
	protected void sequence_NOT(ISerializationContext context, NOT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getNOT_Not1()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getNOT_Not1()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNOTAccess().getNot1NotKeyword_0(), semanticObject.getNot1());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Name returns Name
	 *
	 * Constraint:
	 *     name=IdNew
	 */
	protected void sequence_Name(ISerializationContext context, Name semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getName_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getName_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNameAccess().getNameIdNewParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OF returns OF
	 *
	 * Constraint:
	 *     of='of'
	 */
	protected void sequence_OF(ISerializationContext context, OF semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getOF_Of()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getOF_Of()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOFAccess().getOfOfKeyword_0(), semanticObject.getOf());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ON returns ON
	 *
	 * Constraint:
	 *     on='on'
	 */
	protected void sequence_ON(ISerializationContext context, ON semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getON_On()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getON_On()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getONAccess().getOnOnKeyword_0(), semanticObject.getOn());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OR returns OR
	 *
	 * Constraint:
	 *     or+='or'
	 */
	protected void sequence_OR(ISerializationContext context, OR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutAttr returns OutAttr
	 *     FeaturesOrOutAttr returns OutAttr
	 *
	 * Constraint:
	 *     (attr=Attribute a=AS name=IdNew)
	 */
	protected void sequence_OutAttr(ISerializationContext context, OutAttr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getOutAttr_Attr()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getOutAttr_Attr()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getOutAttr_A()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getOutAttr_A()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getFeaturesOrOutAttr_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getFeaturesOrOutAttr_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutAttrAccess().getAttrAttributeParserRuleCall_0_0(), semanticObject.getAttr());
		feeder.accept(grammarAccess.getOutAttrAccess().getAASParserRuleCall_1_0(), semanticObject.getA());
		feeder.accept(grammarAccess.getOutAttrAccess().getNameIdNewParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OutputAttribute returns OutputAttribute
	 *
	 * Constraint:
	 *     (outAttr=OutAttr | attr_ref=AttributeReference)
	 */
	protected void sequence_OutputAttribute(ISerializationContext context, OutputAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Per1 returns Per1
	 *
	 * Constraint:
	 *     (per='per' exp=Expression)
	 */
	protected void sequence_PER_Per1(ISerializationContext context, Per1 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getPER_Per()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getPER_Per()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getPer1_Exp()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getPer1_Exp()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPERAccess().getPerPerKeyword_0(), semanticObject.getPer());
		feeder.accept(grammarAccess.getPer1Access().getExpExpressionParserRuleCall_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PatternCollectionStatefulSource returns StandardStatefulSource
	 *
	 * Constraint:
	 *     (name=IdNew? bs=BasicSource coll=Collect)
	 */
	protected void sequence_PatternCollectionStatefulSource_StandardStatefulSource(ISerializationContext context, StandardStatefulSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternSourceChain1 returns PatternSourceChain
	 *
	 * Constraint:
	 *     ((psc_2=PatternSourceChain wt=WithinTime?) | (ps=PatternSource wt=WithinTime?))
	 */
	protected void sequence_PatternSourceChain1(ISerializationContext context, PatternSourceChain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternSourceChain returns PatternSourceChain
	 *     PatternSourceChain.PatternSourceChain_1_0_0 returns PatternSourceChain
	 *
	 * Constraint:
	 *     (
	 *         (left=PatternSourceChain_PatternSourceChain_1_0_0 op='->' right=PatternSourceChain1) | 
	 *         (psc_2=PatternSourceChain wt=WithinTime?) | 
	 *         (ps=PatternSource wt=WithinTime?)
	 *     )
	 */
	protected void sequence_PatternSourceChain_PatternSourceChain1(ISerializationContext context, PatternSourceChain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternSource returns PatternSource
	 *
	 * Constraint:
	 *     (lss=LogicalStatefulSource | pss=PatternCollectionStatefulSource | stdss=StandardStatefulSource | logicalAbsStatefulSrc=LogicalAbsentStatefulSource)
	 */
	protected void sequence_PatternSource(ISerializationContext context, PatternSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyName returns PropertyName
	 *
	 * Constraint:
	 *     (na+=Name (ps+=PropertySeparator na+=Name)*)
	 */
	protected void sequence_PropertyName(ISerializationContext context, PropertyName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertySeparator returns PropertySeparator
	 *
	 * Constraint:
	 *     {PropertySeparator}
	 */
	protected void sequence_PropertySeparator(ISerializationContext context, PropertySeparator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyValue returns PropertyValue
	 *
	 * Constraint:
	 *     sv=StringValue
	 */
	protected void sequence_PropertyValue(ISerializationContext context, PropertyValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getPropertyValue_Sv()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getPropertyValue_Sv()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropertyValueAccess().getSvStringValueParserRuleCall_0(), semanticObject.getSv());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     QueryInput returns QueryInput
	 *
	 * Constraint:
	 *     (js=JoinStream | seqSrcChanin=SequenceStream | ps=PatternStream | anonStream=AnonymousStream)
	 */
	protected void sequence_QueryInput(ISerializationContext context, QueryInput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     QuerySection returns QuerySection
	 *
	 * Constraint:
	 *     (grpByQuerySel=GroupByQuerySelection having=HavingExpr?)
	 */
	protected void sequence_QuerySection(ISerializationContext context, QuerySection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternStream returns RightAbsentPatternSource1
	 *     AbsentPatternSourceChain returns RightAbsentPatternSource1
	 *     RightAbsentPatternSource returns RightAbsentPatternSource1
	 *     RightAbsentPatternSource.RightAbsentPatternSource_1_0_0 returns RightAbsentPatternSource1
	 *     RightAbsentPatternSource1 returns RightAbsentPatternSource1
	 *     RightAbsentPatternSource1.RightAbsentPatternSource1_1_0_0 returns RightAbsentPatternSource1
	 *
	 * Constraint:
	 *     (left=RightAbsentPatternSource1_RightAbsentPatternSource1_1_0_0 fb='->' right=EveryAbsentPatternSource)
	 */
	protected void sequence_RightAbsentPatternSource1(ISerializationContext context, RightAbsentPatternSource1 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getRightAbsentPatternSource1_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getRightAbsentPatternSource1_Left()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getRightAbsentPatternSource1_Fb()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getRightAbsentPatternSource1_Fb()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getRightAbsentPatternSource1_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getRightAbsentPatternSource1_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRightAbsentPatternSource1Access().getRightAbsentPatternSource1LeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRightAbsentPatternSource1Access().getFbHyphenMinusGreaterThanSignKeyword_1_0_1_0(), semanticObject.getFb());
		feeder.accept(grammarAccess.getRightAbsentPatternSource1Access().getRightEveryAbsentPatternSourceParserRuleCall_1_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RightAbsentPatternSource1 returns RightAbsentPatternSource
	 *     RightAbsentPatternSource1.RightAbsentPatternSource1_1_0_0 returns RightAbsentPatternSource
	 *     RightAbsentPatternSource2 returns RightAbsentPatternSource
	 *
	 * Constraint:
	 *     (
	 *         (rightAbsPS=RightAbsentPatternSource wt3+=WithinTime?) | 
	 *         (everyPSC1=EveryPatternSourceChain everyAbsPS1=EveryAbsentPatternSource) | 
	 *         (everyAbsPS1=EveryAbsentPatternSource rightAbsPS=RightAbsentPatternSource)
	 *     )
	 */
	protected void sequence_RightAbsentPatternSource2(ISerializationContext context, RightAbsentPatternSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternStream returns RightAbsentPatternSource
	 *     AbsentPatternSourceChain returns RightAbsentPatternSource
	 *     RightAbsentPatternSource returns RightAbsentPatternSource
	 *     RightAbsentPatternSource.RightAbsentPatternSource_1_0_0 returns RightAbsentPatternSource
	 *
	 * Constraint:
	 *     (
	 *         (left1=RightAbsentPatternSource_RightAbsentPatternSource_1_0_0 fb2='->' right1=RightAbsentPatternSource1) | 
	 *         (rightAbsPS=RightAbsentPatternSource wt3+=WithinTime?) | 
	 *         (everyPSC1=EveryPatternSourceChain everyAbsPS1=EveryAbsentPatternSource) | 
	 *         (everyAbsPS1=EveryAbsentPatternSource rightAbsPS=RightAbsentPatternSource)
	 *     )
	 */
	protected void sequence_RightAbsentPatternSource_RightAbsentPatternSource2(ISerializationContext context, RightAbsentPatternSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RightAbsentSequenceSource returns RightAbsentSequenceSource1
	 *     RightAbsentSequenceSource.RightAbsentSequenceSource_1_0_0 returns RightAbsentSequenceSource1
	 *     RightAbsentSequenceSource1 returns RightAbsentSequenceSource1
	 *     RightAbsentSequenceSource1.RightAbsentSequenceSource1_1_0_0 returns RightAbsentSequenceSource1
	 *
	 * Constraint:
	 *     (left=RightAbsentSequenceSource1_RightAbsentSequenceSource1_1_0_0 comm=',' right=SequenceSourceChain)
	 */
	protected void sequence_RightAbsentSequenceSource1(ISerializationContext context, RightAbsentSequenceSource1 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getRightAbsentSequenceSource1_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getRightAbsentSequenceSource1_Left()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getRightAbsentSequenceSource_Comm()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getRightAbsentSequenceSource_Comm()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getRightAbsentSequenceSource1_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getRightAbsentSequenceSource1_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRightAbsentSequenceSource1Access().getRightAbsentSequenceSource1LeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRightAbsentSequenceSource1Access().getCommCommaKeyword_1_0_1_0(), semanticObject.getComm());
		feeder.accept(grammarAccess.getRightAbsentSequenceSource1Access().getRightSequenceSourceChainParserRuleCall_1_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RightAbsentSequenceSource1 returns RightAbsentSequenceSource
	 *     RightAbsentSequenceSource1.RightAbsentSequenceSource1_1_0_0 returns RightAbsentSequenceSource
	 *     RightAbsentSequenceSource2 returns RightAbsentSequenceSource
	 *
	 * Constraint:
	 *     (
	 *         (op=OPEN_PAR rightAbsentSequenceSource=RightAbsentSequenceSource cp=CLOSE_PAR wt7=WithinTime?) | 
	 *         (sequenceSourceChain=SequenceSourceChain comma=',' basicAbsentPatternSource=BasicAbsentPatternSource) | 
	 *         (basicAbsentPatternSource=BasicAbsentPatternSource rightAbsentSequenceSource=RightAbsentSequenceSource)
	 *     )
	 */
	protected void sequence_RightAbsentSequenceSource2(ISerializationContext context, RightAbsentSequenceSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RightAbsentSequenceSource returns RightAbsentSequenceSource
	 *     RightAbsentSequenceSource.RightAbsentSequenceSource_1_0_0 returns RightAbsentSequenceSource
	 *
	 * Constraint:
	 *     (
	 *         (left1=RightAbsentSequenceSource_RightAbsentSequenceSource_1_0_0 comm=',' right1=RightAbsentSequenceSource1) | 
	 *         (op=OPEN_PAR rightAbsentSequenceSource=RightAbsentSequenceSource cp=CLOSE_PAR wt7=WithinTime?) | 
	 *         (sequenceSourceChain=SequenceSourceChain comma=',' basicAbsentPatternSource=BasicAbsentPatternSource) | 
	 *         (basicAbsentPatternSource=BasicAbsentPatternSource rightAbsentSequenceSource=RightAbsentSequenceSource)
	 *     )
	 */
	protected void sequence_RightAbsentSequenceSource_RightAbsentSequenceSource2(ISerializationContext context, RightAbsentSequenceSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SecondValue returns SecondValue
	 *
	 * Constraint:
	 *     (second='second' | seconds='seconds' | sec='sec')
	 */
	protected void sequence_SECONDS(ISerializationContext context, SecondValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SetClause returns SetClause
	 *
	 * Constraint:
	 *     (set='set' setAssignment+=SetAssignment setAssignment+=SetAssignment*)
	 */
	protected void sequence_SET_SetClause(ISerializationContext context, SetClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SequenceSourceChain returns StandardStatefulSource
	 *     SequenceSourceChain.SequenceSourceChain_1_0_0 returns StandardStatefulSource
	 *     SequenceSourceChain1 returns StandardStatefulSource
	 *
	 * Constraint:
	 *     (name=IdNew? bs=BasicSource (coll=Collect | zero_or_more='*' | zero_or_one='?' | one_or_more='+')? wt=WithinTime? wt1+=WithinTime*)
	 */
	protected void sequence_SequenceCollectionStatefulSource_SequenceSourceChain1_StandardStatefulSource(ISerializationContext context, StandardStatefulSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SequenceSource returns StandardStatefulSource
	 *
	 * Constraint:
	 *     (name=IdNew? bs=BasicSource (coll=Collect | zero_or_more='*' | zero_or_one='?' | one_or_more='+')?)
	 */
	protected void sequence_SequenceCollectionStatefulSource_StandardStatefulSource(ISerializationContext context, StandardStatefulSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     SequenceCollectionStatefulSource returns StandardStatefulSource
	//
	// Constraint:
	//     (name=IdNew? bs=BasicSource (coll=Collect | zero_or_more='*' | zero_or_one='?' | one_or_more='+'))
	//
	// protected void sequence_SequenceCollectionStatefulSource_StandardStatefulSource(ISerializationContext context, StandardStatefulSource semanticObject) { }
	
	/**
	 * Contexts:
	 *     SequenceSourceChain returns SequenceSourceChain
	 *     SequenceSourceChain.SequenceSourceChain_1_0_0 returns SequenceSourceChain
	 *     SequenceSourceChain1 returns SequenceSourceChain
	 *
	 * Constraint:
	 *     (left=SequenceSourceChain_SequenceSourceChain_1_0_0 op=',' right=SequenceSourceChain1 wt1+=WithinTime*)
	 */
	protected void sequence_SequenceSourceChain_SequenceSourceChain1(ISerializationContext context, SequenceSourceChain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SequenceStream returns SequenceStream
	 *
	 * Constraint:
	 *     (everySequenceSourceChain=EverySequenceSourceChain | everyAbsentSequenceSourceChain=EveryAbsentSequenceSourceChain)
	 */
	protected void sequence_SequenceStream(ISerializationContext context, SequenceStream semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SiddhiQL returns SiddhiQL
	 *
	 * Constraint:
	 *     elements+=ExecutionPlan+
	 */
	protected void sequence_SiddhiQL(ISerializationContext context, SiddhiQL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Source1OrStandardStatefulSource returns Source1
	 *     Source1 returns Source1
	 *
	 * Constraint:
	 *     (inner='#'? name=IdNew)
	 */
	protected void sequence_Source1(ISerializationContext context, Source1 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SourceOrEventReference returns SourceOrEventReference
	 *
	 * Constraint:
	 *     na=[Source1OrStandardStatefulSource|IdNew]
	 */
	protected void sequence_SourceOrEventReference(ISerializationContext context, SourceOrEventReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getSourceOrEventReference_Na()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getSourceOrEventReference_Na()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSourceOrEventReferenceAccess().getNaSource1OrStandardStatefulSourceIdNewParserRuleCall_0_1(), semanticObject.eGet(SiddhiPackage.eINSTANCE.getSourceOrEventReference_Na(), false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Source returns Source
	 *
	 * Constraint:
	 *     strId=[Source1|IdNew]
	 */
	protected void sequence_Source(ISerializationContext context, Source semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getSource_StrId()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getSource_StrId()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSourceAccess().getStrIdSource1IdNewParserRuleCall_0_1(), semanticObject.eGet(SiddhiPackage.eINSTANCE.getSource_StrId(), false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StandardStatefulSource returns StandardStatefulSource
	 *     Source1OrStandardStatefulSource returns StandardStatefulSource
	 *
	 * Constraint:
	 *     (name=IdNew? bs=BasicSource)
	 */
	protected void sequence_StandardStatefulSource(ISerializationContext context, StandardStatefulSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StreamAlias returns StreamAlias
	 *
	 * Constraint:
	 *     na=Name
	 */
	protected void sequence_StreamAlias(ISerializationContext context, StreamAlias semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getStreamAlias_Na()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getStreamAlias_Na()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStreamAliasAccess().getNaNameParserRuleCall_0(), semanticObject.getNa());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StreamFunction returns StreamFunction
	 *
	 * Constraint:
	 *     fo=FunctionOperation
	 */
	protected void sequence_StreamFunction(ISerializationContext context, StreamFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getStreamFunction_Fo()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getStreamFunction_Fo()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStreamFunctionAccess().getFoFunctionOperationParserRuleCall_1_0(), semanticObject.getFo());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StreamReference returns StreamReference
	 *
	 * Constraint:
	 *     (hash='#'? na=Name aatr_index=AttributeIndex?)
	 */
	protected void sequence_StreamReference(ISerializationContext context, StreamReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StringValue returns StringValue
	 *
	 * Constraint:
	 *     sl=STRING_LITERAL
	 */
	protected void sequence_StringValue(ISerializationContext context, StringValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getStringValue_Sl()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getStringValue_Sl()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringValueAccess().getSlSTRING_LITERALParserRuleCall_0(), semanticObject.getSl());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TimeValue returns TimeValue
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             yv=YearValue 
	 *             mv=MonthValue? 
	 *             wv=WeekValue? 
	 *             dv=DayValue? 
	 *             hv=HourValue? 
	 *             minv=MinuteValue? 
	 *             secv=SecondValue? 
	 *             msecv=MillisecondValue?
	 *         ) | 
	 *         (
	 *             mv=MonthValue 
	 *             wv=WeekValue? 
	 *             dv=DayValue? 
	 *             hv=HourValue? 
	 *             minv=MinuteValue? 
	 *             secv=SecondValue? 
	 *             msecv=MillisecondValue?
	 *         ) | 
	 *         (
	 *             wv=WeekValue 
	 *             dv=DayValue? 
	 *             hv=HourValue? 
	 *             minv=MinuteValue? 
	 *             secv=SecondValue? 
	 *             msecv=MillisecondValue?
	 *         ) | 
	 *         (dv=DayValue hv=HourValue? minv=MinuteValue? secv=SecondValue? msecv=MillisecondValue?) | 
	 *         (hv=HourValue minv=MinuteValue? secv=SecondValue? msecv=MillisecondValue?) | 
	 *         (minv=MinuteValue secv=SecondValue? msecv=MillisecondValue?) | 
	 *         (sv=SecondValue msecv=MillisecondValue?) | 
	 *         msecv=MillisecondValue
	 *     )
	 */
	protected void sequence_TimeValue(ISerializationContext context, TimeValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TriggerName returns TriggerName
	 *
	 * Constraint:
	 *     id=ID
	 */
	protected void sequence_TriggerName(ISerializationContext context, TriggerName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getTriggerName_Id()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getTriggerName_Id()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTriggerNameAccess().getIdIDTerminalRuleCall_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UNIDIRECTIONAL returns UNIDIRECTIONAL
	 *
	 * Constraint:
	 *     unidirectional='unidirectional'
	 */
	protected void sequence_UNIDIRECTIONAL(ISerializationContext context, UNIDIRECTIONAL semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getUNIDIRECTIONAL_Unidirectional()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getUNIDIRECTIONAL_Unidirectional()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUNIDIRECTIONALAccess().getUnidirectionalUnidirectionalKeyword_0(), semanticObject.getUnidirectional());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     WeekValue returns WeekValue
	 *
	 * Constraint:
	 *     (week='week' | weeks='weeks')
	 */
	protected void sequence_WEEKS(ISerializationContext context, WeekValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Win returns Win
	 *
	 * Constraint:
	 *     (window='window' func_op=FunctionOperation)
	 */
	protected void sequence_WINDOW_Win(ISerializationContext context, Win semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getWINDOW_Window()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getWINDOW_Window()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getWin_Func_op()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getWin_Func_op()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWINDOWAccess().getWindowWindowKeyword_0(), semanticObject.getWindow());
		feeder.accept(grammarAccess.getWinAccess().getFunc_opFunctionOperationParserRuleCall_3_0(), semanticObject.getFunc_op());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     WithinTimeRange returns WithinTimeRange
	 *
	 * Constraint:
	 *     (within='within' startPattern=Expression endPattern=Expression?)
	 */
	protected void sequence_WITHIN_WithinTimeRange(ISerializationContext context, WithinTimeRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WithinTime returns WithinTime
	 *
	 * Constraint:
	 *     (within='within' tv=TimeValue)
	 */
	protected void sequence_WITHIN_WithinTime(ISerializationContext context, WithinTime semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getWITHIN_Within()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getWITHIN_Within()));
			if (transientValues.isValueTransient(semanticObject, SiddhiPackage.eINSTANCE.getWithinTime_Tv()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SiddhiPackage.eINSTANCE.getWithinTime_Tv()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWITHINAccess().getWithinWithinKeyword_0(), semanticObject.getWithin());
		feeder.accept(grammarAccess.getWithinTimeAccess().getTvTimeValueParserRuleCall_1_0(), semanticObject.getTv());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     YearValue returns YearValue
	 *
	 * Constraint:
	 *     (year='year' | years='years')
	 */
	protected void sequence_YEARS(ISerializationContext context, YearValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AggregationTime returns aggregation_time_interval
	 *     aggregation_time_interval returns aggregation_time_interval
	 *
	 * Constraint:
	 *     (aggrtimeDur+=AggregationTimeDuration aggrtimeDur+=AggregationTimeDuration*)
	 */
	protected void sequence_aggregation_time_interval(ISerializationContext context, aggregation_time_interval semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
